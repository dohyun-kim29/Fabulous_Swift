# 흐름 제어 구문

1. 반복문		

   - **for~in**구문은 일정 횟수만큼 특정 구문을 반복하고자 할 때 사용된다. 

     `for<루프 상수> in <순회 대상> { 실행할 구문 } `

     `for i in 1...10 { print(i) }`

   - for~in 구문에서 순회 대상으로 사용할 수 있는 데이터에는 **배열, 딕셔너리, 집합, 범위 데이터, 문자열** 등이 있다.

   - for~in 구문에서 루프 상수를 사용할 필요가 없을 때에는 **_(언더바)로 대체**할 수 있다.

     `for _ in 1...10 { print("I'm So Happy)}`

   - for in 을 여러개 겹쳐 더욱 많은 기능을 구현할 수 있다.(**다중 루프**)

     `for i in 1...5 { for j in 1...5 { print("ㅁ")}}`

   - **while**문은 for~in 구문과는 다르게 **조건을 만족하는 동안은 계속 실행되는 구문**이다. 

     `while <조건식> { 실행할 구문 } `

     `while i<2 { print("Hello") i + 1}`

   - while 문의 **조건식 자리에 true 를 넣으면 무한 루프가 생성**된다. (입력 대기 상태를 유지할 때 사용)

     `while true {print("LOVE")}`

   - **repret while**구문은 whille 구문이 조건을 만족하지 못해도 적어도 한 번은 실행 블록의 수행을 보장하는 구문이다.

     `repeat {<실행할 구문>}while<조건식>`

     `repeat {print("bye")} while i<0`

2. 조건문

   - **if**구문은 조건식의 **참과 거짓을 판별**해 분기해주는 많이 사용되는 구문이다. 

     `if<조건식> { 실행할 구문 }`

     `if (a==1) { print("1") }`

   - if 문에는 반드시 Bool 타입의 값으로 판단할 수 있는 조건만이 들어가야 한다.

   - **if~else**구문은 조건식이 **참이 아닐때 실행할 수 있는 구문을 넣을 수 있게** if 문을 확장해주는 구문이다. 

     `if (a==5) {print("0")}`

     `else {print("1")}`

   - if 구문 또한 **여러 개를 중첩해서 사용**할 수 있다.

     `if (mingi==0) {if (junsang==1) {print("wow")} else {print("pig") } } else { print("diet")}`

   - **if~else if**구문은 **비교할 조건이 여러개일 때 사용**하는 조건식이다. if 문 뒤에 else if<조건식> { 실행할 구문 }의 형식으로 작성된다.

     `if (coffee==0) {print(0)} else if (coffee==1) {print(1)} else if (coffee==2) {print(2)} else {print("준상아 스벅 쿠폰 고마웡")}`

   - if 문과 비슷한 **guard**구문은 else 문이 필수지만, **조건식이 참일 경우 실행되는 블록이 없다**. 

     `guard<조건식>else {조건식의 결과가 false일때 실행될 구문}`

     `guard (a==1) else {return 0}`

   - 주로**오류 검출**에 사용된다.

   - guard 문은 if 문으로 대체 가능하다.

   - **#available** 구문은 **OS 버전별로 구문을 나누어 특정 OS에서 실행될 때 오류가 일어나는 것을 처리**해주는 역할을 한다. 

     `if #available (<플랫폼 이름 버전1>, <플랫폼 이름 버전 2>, <플랫폼 이름 버전 n>,  *) { 해당 버전에서 사용할 수 있는 API 구문 } else {API를 사용할 수 없는 황경에 대한 처리}`

   - **switch**구문은 입력받은 **값을 패턴으로 비교하고 그 결과를 바탕으로 실행 블록을 결정**하는 조건문이다.

     ` switch <비교 대상>{case <비교 패턴 1> : <비교 패턴 1이 일치했을 때 실행할 구문> case <비교 패턴 2> : <비교 패턴 2이 일치했을 때 실행할 구문> case <비교 패턴 n> : <비교 패턴 n이 일치했을 때 실행할 구문> default : <어느 비교 패턴과도 일치하지 않을 때 실행할 구문>}`

     `switch (a) { case 1 : print(1)  case 2 : print(2)  defult : printf("error")}`

   - switch 구문에서 패턴이 일치하는 case 구문을 실행하는 대신, 그 다음 case 블록으로 실행 흐름을 전달하는 문법을 **Fall Through**라고 한다. 

   - Swift 의 switch 구문에서는 명시해 주지 않아도 적용하기 때문에 **암시적인 Fall Through** 라고 한다. 이덕분에 Swift에서는 Swich 구문에서 **break문을 생략**할 수있다.(어느 저급 언어와는 다르다)

   - 패턴이 어느 것과도 일치하지 않은 경우를 **switch 문이 실패했다**고 부른다. (따라서 오류 발생, **default문 꼭 필요**)

   - case 패턴을 작성할 때, **하나 이상의 비교 패턴을 연이어 작성할 수 있다**. 

     ` case 0, 1 : print("0, 1")`
     또한 Swift에서는 **switch 문이 부분적으로 일치할 경우 전체가 일치하는것으로 간주**한다. EX)튜플 사용, 범위 데이터

3. 제어 전달문

   - **break**구문은 루프를 조건식의 결과에 상관 없이 강제종료 하는데 사용된다.

     `if (a==1) {while true {printf("Hello")}} else {continue}`

   - **continue**구문은 이 구문 아래의 실행 구문들을 모두 건너뛰고, 다음 반복 루프를 시작하는데 사용된다.

     `switch (a) { case 1 : print(1) continue  case 2 : print(2)  defult : printf("error")}`

   - 결과를 저장할 변수를 선언한 뒤 **.append()** 메소드를 통해 필터링하거나 다른 문자로 번경 할 수 있다.

   - 조건문, 반복문 앞에 레이블 이름과 콜론을 붙여 정확히 흐름 제어가 적용 될 수 있게 해주는 **구문 레이블**을 정의할 수 있다.

     `레이블 이름: 조건, 반복문`

     `sweet: if(a==1) {print("chocolete")}`

   - 중첩된 구문 내에 있는 break문은 **외부 반복문에는 영향을 주지 못한다.**

   - **fallthrough**구문은 **switch 구문에서 case 블록의 실행을 다음 case 블록으로 전달할 때 사용**한다.

     `switch (a) { case 1: { print(1)}} fallthrough case 2: {print(2)}}`

   - **return**구문은 **값을 반환할때 사용**한다.(함수에서 많이 사용)

     `if (a==1) {return 1}`

   ==========