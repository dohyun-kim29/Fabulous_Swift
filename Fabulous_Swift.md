# Swift 기초

1.  Swift 문법이 다른 프로그래밍 언어와 다른 점
     - 헤더 파일을 작성할 필요가 없다.
     - 대소문자를 구분한다.
     - 구문 끝의 세미콜론은 **생략** 가능하다.
     - main 함수가 없다.
     - 문자도 큰따옴표를 사용한다.
     - try ~ catch 방식의 오류 처리를 지원한다.
     - 옵셔널(Optional)이라는 개념이 존재한다.
     ### **<u>객체지향 언어이다.</u>**

2. 변수와 상수
     - 변수(변할 수 있는 수)는 var 키워드로 선언한다. var (변수이름) : (데이터 타입) = (초기화 해줄 값) 의 형식으로 작성된다.
     - 상수(변하지 않는 수)는 let 키워드로 선언한다. let (상수이름) : (데이터 타입) = (초기화 해줄 값) 의 형식으로 작성된다.
     - **이때 변수일 경우에만 선언과 초기화를 분리 할 수 있다.**
     
     **당연한 말이지만 선언해준 변수나 상수를 다른 타입으로 초기화를 하면 오류가 발생한다.**
     
     - 변수와 상수의 이름을 정의할 때 알파벳, 한글 자음, 모음, 아라비아 숫자를 사용할 수 있으며 심지어는 **특수기호나 한자, 이미지용 바이너리 코드까지 사용할 수 있다.** (가능 하다는거지 사용 하라는 것이 아니다.)
     - 변수와 상수명에 연산자와 혼동 가능한 [ + - * / % ] 과 공백은 사용 할 수 없다.
     - Swift 에서 예약어나 키워드로 등록되어있는것 또한 변수, 상수명으로 사용 불가 단, **대소문자를 바꿔서 사용 가능하다.** EX) var Int (X), var int (O)
     - 변수, 상수명의 첫번쨰 자리에 숫자가 올 수 없다.
     
 3. 자료형
    - **Int**는 Int8 기준으로 256 개의 값(**정수**)을 저장 할 수 있다.(127~-128)
    - 컴퓨터의 CPU 에 따라 최대 9223372036854775807~-9223372036854775808 (Int64) 까지 저장할 수 있다.
    - 이러한 값들은 Int.max, Int.min 으로 확인할 수 있다.
    - -범위를 저장할 수 없는 대신 **두 배**(정확히는 두배 +1)의 값을 저장할 수 있는 UInt 가 있다.
    - 실수를 저장할 수 있는 **Float**와 **Double**이 있다.
    - Float 는 32비트, Double은 64비트로 Double을 쓰는 것이 더 오차가 적다.
    - true와 false 두 가지 종류의 값만 가질 수 있는 **Bool** 이 있다.(주로 논리값을 저장)
    - Int와 함께 가장 많이 사용되는 자료형인 문자열을 입력받는 **String** 이 있다.
    - 문자열을 하나씩 분해한 것을 저장할 수 있는 단일 자료형인 **Character**이 된다.
    - 변수를 선언할 때 콜론 뒤에 적는 자료형을 **타입 어노테이션**이라고 한다.
    - 자료형을 결합해야 한다면, **강제적으로 형 변환을 하여** 같은 타입으로 결합해야 한다.
    - Int(<정수로 바꾸고 싶은 문자열>), String("<문자열로 바꾸고 싶은 정수>")
    - **문자열 템플릿은** 매우 중요한 기능이다.  이 기능을 사용하면 문자열 내에서 원하는 변수나 상수의 값을 출력할 수 있다.
    - **\(포함하려는 값이 들어있는 변수나 상수)** 이러한 형식으로 사용할 수 있다.
    - **트리플 쿼우팅(멀티 라인 스트링)** 은 여러 줄에 걸친 긴 문자열을 저장할 때 쓰이는 것이다.
    - 트리플 쿼우팅을 사용하게 된다면, 작성된 문자열은 띄어쓰기나 줄바꿈 등이 작성된 그대로 반영된다. 따라서, 굳이 복잡한 코드를 처리할 필요가 없다.
    - """(줄바꿔서)<입력하고싶은 문자열>(줄바꿔서)"""이러한 형식으로 사용된다.
    - 같은 문자열 내에서 줄 바꿈을 적용하기 위해서는 **리턴 피드(\n)** 를 직접 넣어주어야 한다.
    - 가독성이 좋게 긴 문자열을 나누기 위해서는 문자열들을 + 연산자를 사용해 더해주는 방식이 있다.
    
4. 연산자
    - **산술 연산자**는 사칙 연산에 대한 연산자들로, **- + * / %** 가 있다.
    - Swift는 연산자를 사용할때 **피연산자와 연산자 사이의 공백을 일치시켜주어야 한다** EX) 1 + 1 (O), 1 +1 (X), 1+1 (O)
    - **비교 연산자**는 Bool타입의 값으로 참, 거짓을 의미하는 값을 나타내주며 **< > <= >= == !=** 이 있다.
    - **논리 연산자**는 비교 연산자와 비슷하지만, 값의 크기를 비교하는 **비교 연산자와는 달리 논리 비교를 통해 연산을 수행**한며, **! && ||** 이 있다.
    - **범위 연산자**는 Swift에서만 제공하는 독특한 연산자이다.
    **닫힌 범위 연산자**는 피연산자 두 개를 포함하는 연산자이다. 표현 방식은 a...b 의 형태로 표현한다.
    **반 닫힌 범위 연산자** 는 피연산자 중 왼쪽은 포함하되, 오른쪽은 포함하지 않는 연산자이다. 표현 방식은 a..<b이다.(추후에 나올 for in문에 많이 사용된다.)
    ### **이때 절대 반대 방향으로 사용할 수 없다**
    - **대입 연산자**는 **왼쪽의 값을 오른쪽에 대입하는** 연산자로, =  += -= *= /= %= <<= >>= &= ^= |= 이 있다.

# 흐름 제어 구문

1. 반복문
    - **for~in**구문은 일정 횟수만큼 특정 구문을 반복하고자 할 때 사용된다. for<루프 상수> in <순회 대상> { 실행할 구문 } 의 형식으로 작성된다.
    - for i in 1...10 { print(i) }
    - for~in 구문에서 순회 대상으로 사용할 수 있는 데이터에는 **배열, 딕셔너리, 집합, 범위 데이터, 문자열** 등이 있다.
    - for~in 구문에서 루프 상수를 사용할 필요가 없을 때에는 **_(언더바)로 대체**할 수 있다.
    - EX) for _ in 1...10 { print("I'm So Happy)}
    - for in 을 여러개 겹쳐 더욱 많은 기능을 구현할 수 있다.(**다중 루프**)
    - **while**문은 for~in 구문과는 다르게 **조건을 만족하는 동안은 계속 실행되는 구문**이다. while <조건식> { 실행할 구문 } 의 형식으로 작성된다.
    - EX) while i<2 { print("Hello") i + 1}
    - while 문의 **조건식 자리에 true 를 넣으면 무한 루프가 생성**된다. (입력 대기 상태를 유지할 때 사용)
    - **repret while**구문은 whille 구문이 조건을 만족하지 못해도 적어도 한 번은 실행 블록의 수행을 보장하는 구문이다. repeat {<실행할 구문>}while<조건식>의 형태로 작성된다.

2. 조건문
    - **if**구문은 조건식의 **참과 거짓을 판별**해 분기해주는 많이 사용되는 구문이다. if<조건식> { 실행할 구문 } 의 형식으로 작성된다.
    - EX) if (a==1) { print("1") }
    - if 문에는 반드시 Bool 타입의 값으로 판단할 수 있는 조건만이 들어가야 한다.
    - **if~else**구문은 조건식이 **참이 아닐때 실행할 수 있는 구문을 넣을 수 있게** if 문을 확장해주는 구문이다. if 문 뒤에 else{실행할 구문}을 넣는 형식으로 작성된다.
    - if 구문 또한 **여러 개를 중첩해서 사용**할 수 있다.
    - **if~else if**구문은 **비교할 조건이 여러개일 때 사용**하는 조건식이다. if 문 뒤에 else if<조건식> { 실행할 구문 }의 형식으로 작성된다.
    - if 문과 비슷한 **guard**구문은 else 문이 필수지만, **조건식이 참일 경우 실행되는 블록이 없다**. guard<조건식>else {조건식의 결과가 false일때 실행될 구문} 의 형식으로 작성되며 주로**오류 검출**에 사용된다.
    - guard 문은 if 문으로 대체 가능하다.
    - **#available** 구문은 **OS 버전별로 구문을 나누어 특정 OS에서 실행될 때 오류가 일어나는 것을 처리**해주는 역할을 한다. if #available (<플랫폼 이름 버전1>, <플랫폼 이름 버전 2>, <플랫폼 이름 버전 n>,  *) { 해당 버전에서 사용할 수 있는 API 구문 } else {API를 사용할 수 없는 황경에 대한 처리}의 형식으로 작성된다.
    - **switch**구문은 입력받은 **값을 패턴으로 비교하고 그 결과를 바탕으로 실행 블록을 결정**하는 조건문이다. switch <비교 대상>{case <비교 패턴 1> : <비교 패턴 1이 일치했을 때 실행할 구문> case <비교 패턴 2> : <비교 패턴 2이 일치했을 때 실행할 구문> case <비교 패턴 n> : <비교 패턴 n이 일치했을 때 실행할 구문> default : <어느 비교 패턴과도 일치하지 않을 때 실행할 구문>}의 형식으로 작성된다.
    - switch 구문에서 패턴이 일치하는 case 구문을 실행하는 대신, 그 다음 case 블록으로 실행 흐름을 전달하는 문법을 **Fall Through**라고 한다. 
    - Swift 의 switch 구문에서는 명시해 주지 않아도 적용하기 때문에 **암시적인 Fall Through** 라고 한다. 이덕분에 Swift에서는 Swich 구문에서 **break문을 생략**할 수있다.
    - 패턴이 어느 것과도 일치하지 않은 경우를 **switch 문이 실패했다**고 부른다. (따라서 오류 발생, **default문 꼭 필요**)
    - case 패턴을 작성할 때, **하나 이상의 비교 패턴을 연이어 작성할 수 있다**. EX)  case 0, 1 : print("0, 1")
     또한 Swift에서는 **switch 문이 부분적으로 일치할 경우 전체가 일치하는것으로 간주**한다. EX)튜플 사용, 범위 데이터
    
3. 제어 전달문
    - **break**구문은 루프를 조건식의 결과에 상관 없이 강제종료 하는데 사용된다.
    - **continue**구문은 이 구문 아래의 실행 구문들을 모두 건너뛰고, 다음 반복 루프를 시작하는데 사용된다.
    - 결과를 저장할 변수를 선언한 뒤 **.append()** 메소드를 통해 필터링하거나 다른 문자로 번경 할 수 있다.
    - 조건문, 반복문 앞에 레이블 이름과 콜론을 붙여 정확히 흐름 제어가 적용 될 수 있게 해주는 **구문 레이블**을 정의할 수 있다.
    - 중첩된 구문 내에 있는 break문은 **외부 반복문에는 영향을 주지 못한다.**
    - **fallthrough**구문은 **switch 구문에서 case 블록의 실행을 다음 case 블록으로 전달할 때 사용**한다.
    - **return**구문은 **값을 반환할때 사용**한다.(함수에서 많이 사용)
    
    # 집단 자료형
    
1. 배열
    - **배열**은 **일련의 순서를 가지는 리스트 형식의 값을 저장**하는데에 사용되는 **자료형**이다.
    - **배열 안의 값을 순서대로 일련번호 형식으로 나타내는 것**이 **Index**다.
    ### **Index는 0부터 시작한다.**
    - 배열 중간의 값이 삭제되더라도 다른 값들이 앞으로 이동하며 빈 Index를 채워넣는다.
    - 배열에 저장할 아이템의 타입에는 제약이 없지만, **하나의 배열에 저장하는 아이템 타입은 모두 같아야 한다.**
    - 배열을 선언해줄 때 배열에 저장할 아이템 타입을 명확히 정의해야 한다.
    - **배열의 크기는 동적으로 확장할 수 있다.**
    - 배열은 **정적** 또는 **동적** 으로 정의할 수 있다.
    
     
     

