# Swift 기초

1.  Swift 문법이 다른 프로그래밍 언어와 다른 점
     - 헤더 파일을 작성할 필요가 없다.
     - 대소문자를 구분한다.
     - 구문 끝의 세미콜론은 **생략** 가능하다.
     - main 함수가 없다.
     - 문자도 큰따옴표를 사용한다.
     - try ~ catch 방식의 오류 처리를 지원한다.
     - **옵셔널(Optional)** 이라는 오류를 처리해주는 방법이 존재한다.
     - **nill** 이라는 값이 없다는 것을 나타내는 값이 있다.

     

     ### **<u>객체지향 언어이다.</u>**


2. 변수와 상수
     - 변수(변할 수 있는 수)는 var 키워드로 선언한다. var (변수이름) : (데이터 타입) = (초기화 해줄 값) 의 형식으로 작성된다.
     - 상수(변하지 않는 수)는 let 키워드로 선언한다. let (상수이름) : (데이터 타입) = (초기화 해줄 값) 의 형식으로 작성된다.
     - **이때 변수일 경우에만 선언과 초기화를 분리 할 수 있다.**
     
     **당연한 말이지만 선언해준 변수나 상수를 다른 타입으로 초기화를 하면 오류가 발생한다.**
     
     - 변수와 상수의 이름을 정의할 때 알파벳, 한글 자음, 모음, 아라비아 숫자를 사용할 수 있으며 심지어는 **특수기호나 한자, 이미지용 바이너리 코드까지 사용할 수 있다.** (가능 하다는거지 사용 하라는 것이 아니다.)
     - 변수와 상수명에 연산자와 혼동 가능한 [ + - * / % ] 과 공백은 사용 할 수 없다.
     - Swift 에서 예약어나 키워드로 등록되어있는것 또한 변수, 상수명으로 사용 불가 단, **대소문자를 바꿔서 사용 가능하다.** EX) var Int (X), var int (O)
     - 변수, 상수명의 첫번쨰 자리에 숫자가 올 수 없다.
     
 3. 자료형
    - **Int**는 Int8 기준으로 256 개의 값(**정수**)을 저장 할 수 있다.(127~-128)
    - 컴퓨터의 CPU 에 따라 최대 9223372036854775807~-9223372036854775808 (Int64) 까지 저장할 수 있다.
    - 이러한 값들은 Int.max, Int.min 으로 확인할 수 있다.
    - -범위를 저장할 수 없는 대신 **두 배**(정확히는 두배 +1)의 값을 저장할 수 있는 UInt 가 있다.
    - 실수를 저장할 수 있는 **Float**와 **Double**이 있다.
    - Float 는 32비트, Double은 64비트로 Double을 쓰는 것이 더 오차가 적다.
    - true와 false 두 가지 종류의 값만 가질 수 있는 **Bool** 이 있다.(주로 논리값을 저장)
    - Int와 함께 가장 많이 사용되는 자료형인 문자열을 입력받는 **String** 이 있다.
    - 문자열을 하나씩 분해한 것을 저장할 수 있는 단일 자료형인 **Character**이 된다.
    - 변수를 선언할 때 콜론 뒤에 적는 자료형을 **타입 어노테이션**이라고 한다.
    - 자료형을 결합해야 한다면, **강제적으로 형 변환을 하여** 같은 타입으로 결합해야 한다.
    - Int(<정수로 바꾸고 싶은 문자열>), String("<문자열로 바꾸고 싶은 정수>")
    - **문자열 템플릿은** 매우 중요한 기능이다.  이 기능을 사용하면 문자열 내에서 원하는 변수나 상수의 값을 출력할 수 있다.
    - **\(포함하려는 값이 들어있는 변수나 상수)** 이러한 형식으로 사용할 수 있다.
    - **트리플 쿼우팅(멀티 라인 스트링)** 은 여러 줄에 걸친 긴 문자열을 저장할 때 쓰이는 것이다.
    - 트리플 쿼우팅을 사용하게 된다면, 작성된 문자열은 띄어쓰기나 줄바꿈 등이 작성된 그대로 반영된다. 따라서, 굳이 복잡한 코드를 처리할 필요가 없다.
    - """(줄바꿔서)<입력하고싶은 문자열>(줄바꿔서)"""이러한 형식으로 사용된다.
    - 같은 문자열 내에서 줄 바꿈을 적용하기 위해서는 **리턴 피드(\n)** 를 직접 넣어주어야 한다.
    - 가독성이 좋게 긴 문자열을 나누기 위해서는 문자열들을 + 연산자를 사용해 더해주는 방식이 있다.
    
4. 연산자
    - **산술 연산자**는 사칙 연산에 대한 연산자들로, **- + * / %** 가 있다.
    - Swift는 연산자를 사용할때 **피연산자와 연산자 사이의 공백을 일치시켜주어야 한다** EX) 1 + 1 (O), 1 +1 (X), 1+1 (O)
    - **비교 연산자**는 Bool타입의 값으로 참, 거짓을 의미하는 값을 나타내주며 **< > <= >= == !=** 이 있다.
    - **논리 연산자**는 비교 연산자와 비슷하지만, 값의 크기를 비교하는 **비교 연산자와는 달리 논리 비교를 통해 연산을 수행**한며, **! && ||** 이 있다.
    - **범위 연산자**는 Swift에서만 제공하는 독특한 연산자이다.
    **닫힌 범위 연산자**는 피연산자 두 개를 포함하는 연산자이다. 표현 방식은 a...b 의 형태로 표현한다.
    **반 닫힌 범위 연산자** 는 피연산자 중 왼쪽은 포함하되, 오른쪽은 포함하지 않는 연산자이다. 표현 방식은 a..<b이다.(추후에 나올 for in문에 많이 사용된다.)
    - ### **이때 절대 반대 방향으로 사용할 수 없다**
    - **대입 연산자**는 **왼쪽의 값을 오른쪽에 대입하는** 연산자로, =  += -= *= /= %= <<= >>= &= ^= |= 이 있다.
    
    ==========

# 흐름 제어 구문

1. 반복문
    - **for~in**구문은 일정 횟수만큼 특정 구문을 반복하고자 할 때 사용된다. for<루프 상수> in <순회 대상> { 실행할 구문 } 의 형식으로 작성된다.
    - for i in 1...10 { print(i) }
    - for~in 구문에서 순회 대상으로 사용할 수 있는 데이터에는 **배열, 딕셔너리, 집합, 범위 데이터, 문자열** 등이 있다.
    - for~in 구문에서 루프 상수를 사용할 필요가 없을 때에는 **_(언더바)로 대체**할 수 있다.
    - EX) for _ in 1...10 { print("I'm So Happy)}
    - for in 을 여러개 겹쳐 더욱 많은 기능을 구현할 수 있다.(**다중 루프**)
    - **while**문은 for~in 구문과는 다르게 **조건을 만족하는 동안은 계속 실행되는 구문**이다. while <조건식> { 실행할 구문 } 의 형식으로 작성된다.
    - EX) while i<2 { print("Hello") i + 1}
    - while 문의 **조건식 자리에 true 를 넣으면 무한 루프가 생성**된다. (입력 대기 상태를 유지할 때 사용)
    - **repret while**구문은 whille 구문이 조건을 만족하지 못해도 적어도 한 번은 실행 블록의 수행을 보장하는 구문이다. repeat {<실행할 구문>}while<조건식>의 형태로 작성된다.

2. 조건문
    - **if**구문은 조건식의 **참과 거짓을 판별**해 분기해주는 많이 사용되는 구문이다. if<조건식> { 실행할 구문 } 의 형식으로 작성된다.
    - EX) if (a==1) { print("1") }
    - if 문에는 반드시 Bool 타입의 값으로 판단할 수 있는 조건만이 들어가야 한다.
    - **if~else**구문은 조건식이 **참이 아닐때 실행할 수 있는 구문을 넣을 수 있게** if 문을 확장해주는 구문이다. if 문 뒤에 else{실행할 구문}을 넣는 형식으로 작성된다.
    - if 구문 또한 **여러 개를 중첩해서 사용**할 수 있다.
    - **if~else if**구문은 **비교할 조건이 여러개일 때 사용**하는 조건식이다. if 문 뒤에 else if<조건식> { 실행할 구문 }의 형식으로 작성된다.
    - if 문과 비슷한 **guard**구문은 else 문이 필수지만, **조건식이 참일 경우 실행되는 블록이 없다**. guard<조건식>else {조건식의 결과가 false일때 실행될 구문} 의 형식으로 작성되며 주로**오류 검출**에 사용된다.
    - guard 문은 if 문으로 대체 가능하다.
    - **#available** 구문은 **OS 버전별로 구문을 나누어 특정 OS에서 실행될 때 오류가 일어나는 것을 처리**해주는 역할을 한다. if #available (<플랫폼 이름 버전1>, <플랫폼 이름 버전 2>, <플랫폼 이름 버전 n>,  *) { 해당 버전에서 사용할 수 있는 API 구문 } else {API를 사용할 수 없는 황경에 대한 처리}의 형식으로 작성된다.
    - **switch**구문은 입력받은 **값을 패턴으로 비교하고 그 결과를 바탕으로 실행 블록을 결정**하는 조건문이다. switch <비교 대상>{case <비교 패턴 1> : <비교 패턴 1이 일치했을 때 실행할 구문> case <비교 패턴 2> : <비교 패턴 2이 일치했을 때 실행할 구문> case <비교 패턴 n> : <비교 패턴 n이 일치했을 때 실행할 구문> default : <어느 비교 패턴과도 일치하지 않을 때 실행할 구문>}의 형식으로 작성된다.
    - switch 구문에서 패턴이 일치하는 case 구문을 실행하는 대신, 그 다음 case 블록으로 실행 흐름을 전달하는 문법을 **Fall Through**라고 한다. 
    - Swift 의 switch 구문에서는 명시해 주지 않아도 적용하기 때문에 **암시적인 Fall Through** 라고 한다. 이덕분에 Swift에서는 Swich 구문에서 **break문을 생략**할 수있다.
    - 패턴이 어느 것과도 일치하지 않은 경우를 **switch 문이 실패했다**고 부른다. (따라서 오류 발생, **default문 꼭 필요**)
    - case 패턴을 작성할 때, **하나 이상의 비교 패턴을 연이어 작성할 수 있다**. EX)  case 0, 1 : print("0, 1")
     또한 Swift에서는 **switch 문이 부분적으로 일치할 경우 전체가 일치하는것으로 간주**한다. EX)튜플 사용, 범위 데이터
    
3. 제어 전달문
    - **break**구문은 루프를 조건식의 결과에 상관 없이 강제종료 하는데 사용된다.
    - **continue**구문은 이 구문 아래의 실행 구문들을 모두 건너뛰고, 다음 반복 루프를 시작하는데 사용된다.
    - 결과를 저장할 변수를 선언한 뒤 **.append()** 메소드를 통해 필터링하거나 다른 문자로 번경 할 수 있다.
    - 조건문, 반복문 앞에 레이블 이름과 콜론을 붙여 정확히 흐름 제어가 적용 될 수 있게 해주는 **구문 레이블**을 정의할 수 있다.
    - 중첩된 구문 내에 있는 break문은 **외부 반복문에는 영향을 주지 못한다.**
    - **fallthrough**구문은 **switch 구문에서 case 블록의 실행을 다음 case 블록으로 전달할 때 사용**한다.
    - **return**구문은 **값을 반환할때 사용**한다.(함수에서 많이 사용)
    
    ==========
    
# 집단 자료형

    
1. 배열
    - **배열**은 **일련의 순서를 가지는 리스트 형식의 값을 저장**하는데에 사용되는 **자료형**이다.
    - **배열 안의 값을 순서대로 일련번호 형식으로 나타내는 것**이 **Index**다.
    ### **Index는 0부터 시작한다.**
    - 배열 중간의 값이 삭제되더라도 다른 값들이 앞으로 이동하며 빈 Index를 채워넣는다.
    - 따라서 마지막 인덱스는 배열의 크기보다 항상 1만큼 작다.
    - 배열에 저장할 아이템의 타입에는 제약이 없지만, **하나의 배열에 저장하는 아이템 타입은 모두 같아야 한다.**
    - 배열을 선언해줄 때 배열에 저장할 아이템 타입을 명확히 정의해야 한다.
    - **배열의 크기는 동적으로 확장할 수 있다.**
    - 배열은 **정적** 또는 **동적** 으로 정의할 수 있다.                       
    - 배열을 정적인 방식으로 선언하고 초기화하는법 **var 배열 이름  =  [데이터 1, 데이터2, 데이터n...]**
    - 배열을 **순회 탐색할 때에는 보통 for~in 구문**과 **반 닫힌 범위 연산자**를 많이 사용한다.
    - 배열의 길이를 구할 때에는 배열 변수나 상수에 **.count** 를 붙여주면 된다.
    - 또한 **이터네이터** 를 사용하는 방법이 있다. **for~in 구문에 배열을 넣어주면** 루프 상수에 할당되는 것이다.
    - index(of:) 메소드를 사용해 아이템이 몇 번째 인덱스에 저장되어있는지 알아낼 수 있다.
    - 배열을 동적인 방법으로 선언하고 초기화 할 때는 **var 배열이름  =  Array <아이템 타입> ()** 이러한 방식으로 작성해주면 된다.
    - 배열을 동적인 방법으로 선언할때에는 **선언과 초기화를 분리**할 수 도 있다. **선언   var 배열이름 : Array <아이템 타입>       초기화   선언이 완료된 배열 이름 = Array()**
    - ### **초기화할 때에는 아이템 타입을 생략할 수 있다.**
    - 배열이 비었는지 체크할 때에는 메소드 **isEmpty** 를 사용하면 된다. 이 메소드는 **배열이 비어있으면 true, 비어있지 않으면 false를 반환**한다.
    - 배열에 값을 동적으로 추가하고 싶을 때에는 **append( _:)**, **insert( _:at:)**, **append(contentsOf:)** 이 3 가지의 메소드를 활용한다.
    - **append(_:)** 메소드는 **배열의 크기를 1만큼 확장하고, 입력된 값을 배열의 맨 뒤에 추가한다.** 
    - **insert(_:at:)** 메소드는 **아이템을 끼어들기 시켜 원하는 위치에 넣을 때 사용된다. at 뒤에 입력되는 정수값은 배열에서 아이템이 추가될 인덱스의 위치를 의미한다.**
    - **append(contentsOf:)** 메소드는 **여러 개의 아이템을 배열에 한꺼번에 추가할 때 쓰는 메소드이다.**
    - **입력된 배열값을 번경하고 싶을 때에는 기존 인덱스에 연결된 아이템을 교체하면 된다.** EX) arr[3] = "ramen"
    - 단 **없는 인덱스에 배열을 추가할 수는 없다.** 이 경우 **오류가 발생**한다.
    - **범위 연산자를 이용하여 인덱스를 참조할 수 있다.**

2. 집합
    - **집합**은 **같은 타입의 서로 다른 값을 중복 없이 저장**하고자 할 때 사용되는 **집단 자료형**이다.
    - 주로 **중복 없이 한 번만 저장되어야 하는 데이터를 다룰 때 배열 대신 사용한다.**
    - ### **인덱스가 없다.**
    - **해시 연산**의 결과값을 이용하여 데이터를 저장하므로, **Hashable 프로토콜을 구현해야 한다.**
    - **Set**이란 키워드를 사용하여 정의한다. EX) var meal : Set = ["시리얼", "우유", "치킨텐더"]
    - 나머지 값으로 사용되는 데이터 리터럴은 배열과 동일하다.
    - 빈 배열을 작성하려면 **타입 어노테이션에서 아이템 타입을 작성해야 한다.** EX) var 급식 : Set<String> = ["밥", "국", "음료수"]
    - **isEmpty 메소드 사용 가능하다.**
    - 집합과 동일한 방식으로 순회 탐색을 할 수 있다.
    - **sorted()** 메소드를 사용하여 정렬할 수 있다.(abc순서대로)
    - 집합에 아이템을 동적으로 추가할 떄에는 **배열과 동일하게 insert(_:) 메소드를 사용**한다.
    - 다만 **삭제할 때에는 remove(_:)메소드를 사용**한다. 
    - 그러나 **삭제할 값이 집합에 없으면 remove(:_)메소드는 아무것도 삭제하지 않고 nil 을 반환**한다.
    - **contains(_:)** 메소드는 인자값으로 입력된 데이터를 사용하여 **집합 안에 일치하는 데이터가 있는지 없는지 알려준다.**(Bool값으로 알려준다.)
    - **집합끼리는 연산을 할 수 있다.**  EX) arr1.intersection(arr2)
    - **intersection(_:) 메소드는 양쪽에서 공통된 아이템만 선택하여 새로운 집합을 만들어준다.**
    - **symmetric Difference(_:) 메소드는 양쪽에서 어느 한 쪽에만 있는 아이템을 선택하여 새로운 집합을 만들어준다.(공통으로 있는 아이템은 제외)**
    - **union(_:) 메소드는 양쪽 모두에 있는 아이템을 모두 선택해 새로운 집합을 만들어준다.(공통으로 있는 아이템이라고 해서 중복되지 않음)**
    - **subtract(_:) 메소드는 한쪽 집합에 있는 모든 아이템에서 다른쪽 집합에도 속하는 공통 아이템을 제외하고 새로운 집합을 만들어준다.**
    - subtract(_:) 메소드를 제외하고는 양쪽 집합의 위치가 바뀌어도 결과는 동일하다.
    -   또한 포함관계를 판단해주는 연산도 가능하다.
    - **isSubject(of:) 메소드는 주어진 집합의 값 전체가 특정 집합에 포함되는지 여부를 판단하여 Bool 값을 반환해준다.**
    - **isSuperest(of:) 메소드는 주어진 집합이 특정 집합의 모든 값을 포함하는지흫 판단하여 Bool 값을 반환해준다.**
    - **isStrictSubject(of:)와 isStrictSuperset(of:) 메소드는 위의 두 메소드와 같지만, 두 집합이 서로 완전히 같은 경우 결과값을 다르게 반환해준다.(그냥 조금 더 엄격하다 정도..?)**
    - **isDisjoint(with:) 메소드는 두 집합 사이의 공통 값을 확인하여 아무런 공통 값이 없을 때 true, 하나라도 있으면 false를 반환해준다.**
    -  배열을 집합으로 번경한 뒤 다시 배열로 변경해 손쉽게 중복 값 제거가 가능하다,

3. 튜플
    -  **하나의 튜플에 여러가지 타입의 아이템을 저장 가능 하다.**
    - **상수의 성격을 띄어 한번 선언되면 값을 추가하거나 삭제 불가능하다.**
    - **소괄호를 써서 정의한다.** EX) var tp = ("a", "b", 1, 2.2, true)
    - **인덱스를 점으로 표기한다.** EX) tp.0
    - 없는 인덱스를 참조시 오류가 발생한다,
    - 아이템을 개별 변수나 상수로 할당받는 **바인딩**이 가능하다.
    - **순회 탐색이 불가능하다.**
    - 바인딩을 할 때 사용하지 않을 튜플 아이템은 언더바로 대체가 가능하다.
    
4. 딕셔너리
    - **고유 키와 그에 대응하는 값을 연결하여 데이터를 저장하는 자료형이다.**
    - 정의 형식은 **[ 키 : 데이터, 키 : 데이터]** 이런 식으로 정의할 수 있다.
    - **하나의 키는 하나의 데이터에만 연결되어야 한다.**
    - **같은 딕셔너리 내에서 키는 중복될 수 없다.**(중복해서 선언하면 아이템 수정으로 간주.)
    - **데이터 타입엔 제한이 없으나, 하나의 딕셔너리 내에서는 같은 자료형을 사용하여야 한다.**
    - **순회 탐색이 가능하다.**
    - **키의 타입은 해시 연산이 가능해야 한다.**
    - 빈 딕셔너리의 선언은 **Dictionary** 키워드를 통해 할 수 있다. EX) Dictionary <int, string> ( )
    - 이것을 간단한 방식으로 줄이면 **[ 키로 사용할 타입 : 값으로 사용할 타입 ] ( )** 이렇게 선언해줄 수 있다.
    - 딕셔너리 역시 isEmpty 메소드를 사용할 수 있다.
    - **updateValut(_:forKey:)** 메소드를 통해 딕셔너리에 값을 할당할 수 있다. <딕셔너리 객체>.updateValue(<저장할 데이터>, forKey:<데이터를 참조 및 저장하는 데 사용할 키>)
    - **removeValue(forKey:)** 메소드를 통해 딕셔너리에 값을 삭제할 수 있다.
    - ### 딕셔너리에서 키를 호출해서 저장된 값을 불러올 때 **옵셔널** 형태로 반환한다.


=========


# 옵셔널


### **옵셔널 타입**은 **nill** 을 사용할 수 있는 타입을 부르는 말이다.

1. nill
    - **값이 없다** 는 것을 나타내주는 특수한 값이다.
    - nill을 반환하려면 해당 타입이 옵셔널 타입으로 정의되어있어야 한다.
    - **정상적으로 값을 처리하지 못하는 상황이 발생하였을 때 nill을 반환**한다.
    - **자료형에는 nill을 대입할 수 없다.**
    - **옵셔널 타입으로 선언된 자료형에는 nill을 대입할 수 있다.**
    - **모든 기본 자료형 앞에 Optional을 붙이면 옵셔널 타입이 된다.** EX) Optional Int, Optional String
    - Swift 에서 옵셔널 타입이 가질 수 있는 값은 **nill이 아닌 값**과 **nill 값** 두 가지뿐이다.
    - **성공적으로 처리되면 옵셔널로 감싸진 결과값이 반환되고. 문제가 있으면 nill이 반환된다.** EX) Optional(123)
    - ### **옵셔널 타입은 반환하려는 값을 옵셔널로 감싼 형태이다.**
    - 옵셔널로 싸여있는 것을 **옵셔널 래핑** 이라고 하고, 이를 헤제하는 과정을 **옵셔널 언래핑**이라고 한다.

2. 옵셔널 타입 선언, 정의
    - ### **자료형 뒤에 ? 를 붙인다.**

3.  옵셔널 값 처리
    - **옵셔널 언래핑을 해야지만 연산, 대입이 가능하다.**
    - 옵셔널 언래핑의 방법에는 **명시적 해제**와 **묵시적 해제**가 있다.
    - 명시적 해제법에는 **강제 해제**와 **비강제 해제**가 있다.
    - 묵시적 해제법에는 **컴파일러에 의한 자동 해제**와, **! 연산자를 사용한 자동 해제**법이있다.
    - ### **옵셔널 타입의 값 뒤에 !(강제 해제 연산자) 를 붙이면 강제 해제가 된다.**
    - 하지만 **강제 해제 연산자를 사용하였을 때엔 nill 값일때도 강제 해제가 되어 오류가 발생**한다.
    - **옵셔널 바인딩**을 통해 안전하게 해제가 가능하다.
    - 옵셔널 바인딩은 **조건문 내에서 일반 상수에 옵셔널 값을 대입하는 방식**이다.
    - 컴파일러에 의해 옵셔널이 자동으로 해제되는 경우가 있다.(**비교 연산을 처리할 때**)
    - ### **!연산자를 사용해 옵셔널 타입을 선언할 수 있는데 이 때 옵셔널의 묵시적 해제가 일어나 일반 변수처럼 다룰 수 있다.**
    - **이때 변수의 값이 nill이 될 가능성이 있다면 사용해서는 안된다.**
    
    
=========


# 함수


1. 함수의 개념
    - **인자값 또는 파라미터**를 입력받아 **반환값 또는 리턴값**을 내어놓는다.
    - 인자값이 **없을수도**있다.
    - 집단 자료형에 담아서 반환할 수도 있다.
    - **일반 함수**와 **사용자 정의 함수**로 나눌 수 있다.
    - 일반 함수는 기본적인 데이터의 처리나 연산 등을 수행하기 위한 목적으로 사용된다.
    - 사용자 정의 함수는 우리가 원하는 기능들을 실행해줄 함수를 직접 만들어 사용할 수 있는 함수를 말한다.
    - 동일한 코드가 여러 곳에서 사용될 때 이를 함수화하면 재작성할 필요 없이 함수 호출만으로 처리할 수 있다.
    - 전채 프로세스를 하나의 소스 코드에서 연속적으로 작성하는 것보다 기능 단위로 함수화하면 가독성이 좋아지고, 코드와 로직을 이해하기 쉽다.
    - 로직을 번경할때 함수 내부만 수정하면 되므로 유지 보수가 용이하다.
    - 함수는 **func** 키워드로 정의할 수 있다.
    - func 함수이름(매개변수 1: 타입, 매개변수2: 타입, ...) -> 반환타입 {
    실행내용
    return 반환값 }의 형식으로 정의된다.
    -  이떄 **연산자와 예약어는 사용할 수 없다.**
    - 함수의 이름에 사용할 수 있는 문자들은 영어나 숫자, 한자, 바이너리 이미지 등 다양하다.
    - **단 첫글자는 반드시 영어 또는 언더비로 시작해야 한다.**
    - **반환 타입을 생략함으로써 반환값이 없음을 표현할 수 있다.**
    - 처리값을 반환하는 키워드는 **return**이다.
    - 반환값이 없는 함수일 경우에도 **함수의 실행을 명시적으로 종료할 목적으로**사용된다.
    - **함수를 호출할 때에는 함수의 이름에 괄호를 붙이면 실행된다.**
    - 매개변수를 가지고 있는 함수는**괄호 안에 인자값을 넣어서 호출**해야 한다.
    - 매개변수를 가지고 있는 함수는 인자 레이블을 붙여주어야 한다.
    
2. 매개변수 
    - 매개변수는 **내부 매개변수**와 **외부 매개변수**로 나눌 수 있다.
    - 내부 매개변수는 **함수가 내부적으로 인자값을 참조하기 위해 사용하는 변수**이다.
    - 외부 매개변수는 **함수 외부에서 함수나 인자값을 구분하기 위해 사용하는 변수**이다.
    - 외부 매개변수를 명시적으로 정의하면 **외부 매개변수가 인자 레이블이 된다.**
    - 외부 매개변수를 정의하는 방법은 내부 매개변수 앞에 매개변수명을 넣어주기만 하면 된다.
    -  **언더바를 사용하여 외부 매개변수명을 생략할 수 있다.**
    - 매개변수가 **여러개일떄는 일부만 생략 할 수도 있다.**
    - **매개변수명 뒤에 ... 연산자를 붙여 가변적인 개수의 인자값을 받을 수 있다.**
    - 이를 **가변인자**라고 하는데 입력 개수를 특정할 수 없는 형태의 매개변수에 사용된다.
    - for~in문을 이용한 순회 탐색으로 모든 인자값을 순서대로 읽어 들일 수 있다.
    - 매개변수는 **기본값**을 가질 수 있다.
    - 기본값을 입력하는 방법은 **매개변수 타입 다음에 대입 연산자인 = 를 추가하고 기본값을 작성해주면 된다.**
    - **함수에 입력된 인자값은 함수 내부에서 상수로 정의된다.**
    - ### **함수 내부에서 매개변수와 동일한 이름의 변수를 정의하고, 매개변수의 값을 대입해주면 매개변수의 값이 수정된다.**
    - **타입 표현이 들어있던 곳에 inout 키워드를 넣고 타입 변수를 그 뒤쪽으로 밀어내고 & 연산자를 붙여주면 인자값이 할당된 데이터가 저장되어있는 메모리 주소를 함수 내부로 전달해준다.**
    - 함수 외부에서 정의된 변수를 내부에서 가져다 사용하면 inout 키워드를 사용하지 않고도 외부의 변수를 내부에서 바로 참조 가능하다.
    - 프로그램 최상위 레벨에서 작성된 변수를 **전역 변수** 라고 한다.
    - **지역 변수**는 선언된 블록 범위 안에서만 참조할 수 있는 변수이다.
    - 전역 변수는 **모든 블록 내에서 사용 가능** 하지만, 지역변수는 **선언된 블록을 벗어나면 메모리에서 해제되고, 아예 존재하지 않는 변수가 된다.**
    - 함수는 **실행 블록을 가지고 있는 객체**이다.
    - Swift 에서 함수의 외부와 내부에 각각 같은 이름의 변수가 존재하면 내부에서 선언된 변수는 외부와 상관없이 새롭게 생성된다.
    - 이 경우 두 변수는 같은 변수가 아니다.

3. 일급 함수
    - 일급 함수는 **변수나 상수에 함수를 대입할 수 있다.**
    - 이때 **함수의 결과값을 대입하는 것이 아니라, 함수 자체를 대입하는 것이다.**
    - 함수를 대입하는 과정에서 함수가 실행되지는 않는다. **객체 자체만 전달된다.**
    - 함수가 대입된 변수나 상수를 함수처럼 호출하면 그때 함수가 실행된다.
    - 변수에 함수를 대입하면 **함수 타입**이 된다.
    - **( 인자 타입1, 인자 타입2, ... ) -> 반환 타입** 의 형식으로 작성해주면 된다.
    - ### **함수 정의 구문에서는 반환 타입을 생략할 수 있지만, 함수 타입에서는 Void라고 명시해 주어야 한다.**
    - **Void**는 빈 튜플을 나타내는 값으로, 타입알리어스로 정의된 단어이다. **(객체가 아니라 키워드이다.)**
    - 일급 함수는 **함수의 반환 타입으로 함수를 사용할 수 있다.**
    - 일급 함수는 **함수의 인자값으로 함수를 사용할 수 있다.**
    - **콜백 함수**는 특정 구문의 실행이 끝나면 시스템이 호출하도록 처리된 함수이다.
    - 이런식으로 중계 역할을 하는 함수를 **브로커**라고 한다.
    - **defer** 구문은 함수나 메소드에서 코드의 흐름과 상관없이 가장 마지막에 실행되는 블록이다.
    - **지연 블록** 이라고도 불리는데 이 블록에 작성된 구문은 작성된 위치에 상관없이 항상 함수의 종료 직전에 실행되므로 종료 시점에 맞추어 처리하려는 구문이 있을 떄 유용하게 사용된다.
    - defer 블록의 특성은 다음과 같다.
    - 함수가 종료되기직전에 실행된다.
    - defer 블록을 읽기 전에 함수의 실행이 종료될 경우 defer 블록은 실행되지 않는다.
    - 하나의 함수나 메소드 안에서 defer 블록을 여러 번 사용할 수 있다. 이때 **가장 마지막에 작성된 defer 블록부터 역순으로 실행된다.**
    - defer 블록은 중첩해서 사용이 가능하다. 이떄 **가장 바깥쪽에 defer 블록부터 실행된다.**
    - Swift 에서도 익명 일회성 함수인 **클로저**를 지원한다.
    - Swift 에서는 함수를 중첩해서 작성할 수 있다. 이렇게 작성된 함수를 **중첩 함수**라고 한다.
    - 이때 함수 내에 작성된 함수를 **내부 함수**, 밖에 작성된 함수를 **외부 함수**라고 한다.
    - 내부 함수를 외부 함수의 실행과 종료 사이에서 생겼다가 사라진다.
    - 내부 함수는 외부 함수를 거치지 않으면 접근할 수 없다. 이를 이용해 함수의 은닉성을 높일 수 있다.
    - 다음은 클로저에 대한 설명이다.
    - 클로저는 두 가지로 이루어진 객체이다. 하나는 **내부 함수**이며, 또 다른 하나는 **내부 함수가 만들어진 주변 환경**이다.
    - 클로저는 외부 함수 내에서 내부 함수를 **반환**하고, **내부 함수가 외부 함수의 지역 변수나 상수를 참조할 때 만들어진다.**
    - 클로저를 요약하자면 **내부 함수와 이 함수를 둘러싼 주변 객체들의 값을 함꼐 의미하는 것**이다.
    
4. 클로저
    - Swift 에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나이다.
    - 전역함수 : 이름이 **있으며**, **주변 환경에서 캡처할 어떤 값도 없는 클로저**
    - 중첩함수 : 이름이 **있으며**, **자신을 둘러싼 함수로부터 값을 캡처할 수 있는 클로저**
    - 클로저 표현식 : 이름이 **없으며**, **주변 환경으로부터 값을 캡처할 수 있는 경량 문법으로 작성된 클로저**
    - 클로저 표현식은 함수와 달리 **생략되는 부분이 많다.**
    - **func 키워드, 이름을 생략한다.**
    - **{(매개변수) -> 반환 타입 in 실행할 구문 }** 의 형태로 쓰인다.
    - **반환값이 없는 경우 이를 명시적으로 Void를 이용해 표현할 수 있다.**
    - **클로저 표현식은 그 자체로 함수라고 할 수 있다.**
    - 클로저 표현식은 대부분 **인자값으로 함수를 넘겨주어야 할 떄 사용된다.** 하지만 직접 실행해볼수있는 두 가지 방법이 있다.
    - **일급 함수로써의 특성을 활용하여 상수나 변수에 클로저 표현식을 할당하고 실행하는 방식**이 있다.
    - 클로저 표현식을 할당받을 상수까지 생략하고 싶다면, **클로저 표현식 전체를 소괄호로 감싸고, 여기 함수 호출자를 붙히면 클로저 표현식이 실행된다.**
