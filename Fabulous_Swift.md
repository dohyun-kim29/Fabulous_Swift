# 목차

1. Swift 기초
     - 기초
     - 변수와 상수
     - 자료형
     - 연산자

        
     
2. 흐름 제어 구문
     - 반복문
     - 조건문
     - 제어 전달문

        
     
3. 집단 자료형
     - 배열
     - 집합
     - 튜플
     - 딕셔너리
     
        
     
4. 옵셔널
     - nill
     - 옵셔널 타입 선언, 정의
     - 옵셔널 값 처리
     
        
     
5. 함수
     - 함수의 개념
     - 매개변수
     - 일급 함수
     - 클로저

        
     
6. 구조체와 클래스
     - 구조체와 클래스의 기본개념
     - 프로퍼티
     - 메소드
     - 상속
     - 타입 캐스팅
     - 초기화 구문
     - 옵셔널 체인

        
     
7. 열거형과 익스텐션
     - 열거형의 기본 개념
     - 열거형의 정의
     - 익스텐션

        
     
8. 프로토콜
     - 프로토콜의 정의
     - 타입으로서의 프로토콜
     - 델리게이션
     - 프로토콜의 활용
     
        
     
9. 오류처리

     =========









# Swift 기초

1.  Swift 문법이 다른 프로그래밍 언어와 다른 점
     - 헤더 파일을 작성할 필요가 없다.
     - 대소문자를 구분한다.
     - 구문 끝의 세미콜론은 **생략** 가능하다.
     - main 함수가 없다.
     - 문자도 큰따옴표를 사용한다.
     - try ~ catch 방식의 오류 처리를 지원한다.
     - **옵셔널(Optional)** 이라는 오류를 처리해주는 방법이 존재한다.
     - **nill** 이라는 값이 없다는 것을 나타내는 값이 있다.

     

     ### **<u>객체지향 언어이다.</u>**
     
     


2. 변수와 상수
     - 변수(변할 수 있는 수)는 var 키워드로 선언한다. 
     
       ```Swift
       var 변수이름 = 값
       ```
       
       ``` swift
       var keyboard = 1
       ```
       
       
       
       상수(변하지 않는 수)는 let 키워드로 선언한다. 
       
       ```swift
       let 상수이름 = 값
       ```
       
       ```swift
       let guitar = 1
       ```
       
       
       
     - **이때 변수일 경우에만 선언과 초기화를 분리 할 수 있다.**
     
       
     
     - **변수나 상수의 이름 뒤에 타입 어노테이션을 붙여 자료형을 명시할수 있다.**
     
       ```swift
       var/let 변수이름 : 자료형 = 값
       ```
     
       ```swift
       var foo : Int = 1
       ```
     
       
     
       
     
     **당연한 말이지만 선언해준 변수나 상수를 다른 타입으로 초기화를 하면 오류가 발생한다.**
     
     
     
     - 변수와 상수의 이름을 정의할 때 알파벳, 한글 자음, 모음, 아라비아 숫자를 사용할 수 있으며 심지어는 **특수기호나 한자, 이미지용 바이너리 코드까지 사용할 수 있다.** (가능 하다는거지 사용 하라는 것이 아니다.)
     
       
     
     - 변수와 상수명에 연산자와 혼동 가능한 [ + - * / % ] 과 공백은 사용 할 수 없다.
     
       
     
     - Swift 에서 예약어나 키워드로 등록되어있는것 또한 변수, 상수명으로 사용 불가 단, **대소문자를 바꿔서 사용 가능하다.** 
     
       ```swift
       var Int (X)
       var int (O)
       ```
     
       
     
     - 변수, 상수명의 첫번쨰 자리에 숫자가 올 수 없다.
     
     
     
 3. 자료형
   
    - **Int**는 Int8 기준으로 256 개의 값(**정수**)을 저장 할 수 있다.(127~-128)
    
      ```swift
      var macbookPro : Int = 0
      ```
    
      
    
    - 컴퓨터의 CPU 에 따라 최대 9223372036854775807~-9223372036854775808 (Int64) 까지 저장할 수 있다.
    
      
    
    - 이러한 값들은 Int.max, Int.min 으로 확인할 수 있다.
    
      ```swift
      print(Int.max)
      print(Int.min)
      ```
    
      
    
    - -범위를 저장할 수 없는 대신 **두 배**(정확히는 두배 +1)의 값을 저장할 수 있는 UInt 가 있다.
    
      
    
    - 실수를 저장할 수 있는 **Float**와 **Double**이 있다.
    
      ```swift
      var airpods : Float = 3.33
      var iPhone : Double = 4.56
      ```
    
    - Float 는 32비트, Double은 64비트로 Double을 쓰는 것이 더 오차가 적다.
    
      
    
    - true와 false 두 가지 종류의 값만 가질 수 있는 **Bool** 이 있다.(주로 논리값을 저장)
    
      ```swift
      var appleWatch : Bool = true
      var milk : Bool = false
      ```
    
      
    
    - Int와 함께 가장 많이 사용되는 자료형인 문자열을 입력받는 **String** 이 있다.
    
      ```swift
      var monsterRat : String = "노랑시티장쥐환"
      ```
    
      
    
    - 문자열을 하나씩 분해한 것을 저장할 수 있는 단일 자료형인 **Character**이라고 한다.
    
      
    
    - 변수를 선언할 때 콜론 뒤에 적는 자료형을 **타입 어노테이션**이라고 한다.
    
      
    
    - 자료형을 결합해야 한다면, **강제적으로 형 변환을 하여** 같은 타입으로 결합해야 한다.
    
      ```swift
      Int(정수형으로 바꾸고 싶은 문자열), String("문자열로 바꾸고 싶은 정수형")
      ```
    
      
    
    - 문자열 템플릿은** 매우 중요한 기능이다.  이 기능을 사용하면 문자열 내에서 원하는 변수나 상수의 값을 출력할 수 있다.
    
      아래와 같은 형식으로 사용할 수 있다.
    
      ```Swift
      var somethingToEat = "뿌링클 순살에 치즈볼"
      
      print("나는 \(somethingToEat) 이 먹고싶어요")
      
      -------result---------
      나는 뿌링클 순살에 치즈볼이 먹고싶어요
      
      ```
    
      
    
    - **트리플 쿼우팅(멀티 라인 스트링)** 은 여러 줄에 걸친 긴 문자열을 저장할 때 쓰이는 것이다.
    
    - 트리플 쿼우팅을 사용하게 된다면, 작성된 문자열은 띄어쓰기나 줄바꿈 등이 작성된 그대로 반영된다. 따라서, 굳이 복잡한 코드로 처리할 필요가 없게된다.
    
      ```swift
      """
      I LOVE 
      JunSang
      """
      ```
    
      
    
    - 같은 문자열 내에서 줄 바꿈을 적용하기 위해서는 **리턴 피드(\n)** 를 직접 넣어주어야 한다.
    
      ```swift
      print("Apdo\nRalo\nPaka")
      
      ------result------
      Apdo
      Ralo
      Paka
      
      ```
    
      
    
    - 가독성이 좋게 긴 문자열을 나누기 위해서는 문자열들을 + 연산자를 사용해 더해주는 방식이 있다.
    
      ```Swift
    var tuna = "참치"
      var mayo = "마요"
    
      print(tuna + mayo)
      
      ------result------
      참치마요
      
      ```
      
      
    
4. 연산자
    - **산술 연산자**는 사칙 연산에 대한 연산자들로, **-  +  *  /  %** 가 있다.

    - Swift는 연산자를 사용할때 **피연산자와 연산자 사이의 공백을 일치시켜주어야 한다.**

      ```swift
      1 + 1 (O)
      1 +1 (X)
      1+1 (O)
      ```

      

    - **비교 연산자**는 Bool타입의 값으로 참, 거짓을 의미하는 값을 나타내주며 **<  >  <=  >=  ==  !=** 이 있다. 

      ```swift
      var foo = 1
      var bar = 2
      
      foo < bar //true
      ```

      

    - **논리 연산자**는 비교 연산자와 비슷하지만, 값의 크기를 비교하는 **비교 연산자와는 달리 논리 비교를 통해 연산을 수행**하며, **!  &&  ||** 이 있다.

      ```Swift
      var foo = 1
      var bar = 2
      
      foo||bar //foo or bar
      ```

      

      

    - **범위 연산자**는 Swift에서만 제공하는 독특한 연산자이다.
      **닫힌 범위 연산자**는 피연산자 두 개를 포함하는 연산자이다. 

      ```swift
    var foo = 1
      var bar = 2

      foo...bar //1, 2
      ```
    ```
      
      
      
      **반 닫힌 범위 연산자** 는 피연산자 중 왼쪽은 포함하되, 오른쪽은 포함하지 않는 연산자이다. 
      
      ```swift
      var foo = 1
      var bar = 4
      
      foo..<bar //1, 2, 3
    ```
    
      
    
- 추후에 나올 for in문에 많이 사용된다.
    
  
    
- ### **이때 절대 반대 방향으로 사용할 수 없다**
    
  
    
- **대입 연산자**는 **왼쪽의 값을 오른쪽에 대입하는** 연산자로, =  +=  -=  *=  /=  %=  <<=  >>=  &=  ^=  |= 이 있다.
    
      ```swift
      let foo = 1
      var bar = 0
      
      foo = bar
      print(bar)
      
      ------result------
      1
      
  ```
    
  
    
    ==========

# 흐름 제어 구문

1. 반복문		
    - **for~in**구문은 일정 횟수만큼 특정 구문을 반복하고자 할 때 사용된다. 
    
      ```swift
      for 루프상수 in 순회대상 { 
        실행할 구문
      }
      ```
    
      ```swift
      var i = 1
      
      for i in 1...10 { 
        print(i)
      }
      
      ------result------
      1
      2
      3
      4
      5
      6
      7
      8
      9
      10
      
      ```
    
      
    
    - for~in 구문에서 순회 대상으로 사용할 수 있는 데이터에는 **배열, 딕셔너리, 집합, 범위 데이터, 문자열** 등이 있다.
    
      
    
    - for~in 구문에서 루프 상수를 사용할 필요가 없을 때에는 **_(언더바)로 대체**할 수 있다.
    
      ```Swift
      for _ in 1...5 {
        print("오늘 점심은 탕수육")
      }
      
      ------result------
      오늘 점심은 탕수육
      오늘 점심은 탕수육
      오늘 점심은 탕수육
      오늘 점심은 탕수육
      오늘 점심은 탕수육
      
      ```
    
      
    

- for~in 구문을 여러개 겹쳐 더욱 많은 기능을 구현할 수 있다.(**다중 루프**)

  ```Swift
  for _ in 1...2 {
    for _ in 1...4 {
      print("ㅁ")
    }
    print("\n")
  }
  
  ------result------
  ㅁ
  ㅁ
  ㅁ
  
  ㅁ
  ㅁ
  ㅁ
  
  ```

  

- **while**문은 for~in 구문과는 다르게 **조건을 만족하는 동안은 계속 실행되는 구문**이다. 

  ```swift
  while 조건식 {
    실행할 구문
  }
  ```

  ```swift
  var i = 0
  
  while i < 3 {
    print("기모링")
    i += 1
  }
  
  ------result------
  기모링
  기모링
  기모링
  
  ```

  

- while 문의 **조건식 자리에 true 를 넣으면 무한 루프가 생성**된다. (입력 대기 상태를 유지할 때 사용)

  ```Swift
  while true {
    print("이성진 홍삼캔디 3주압수")
  }
  
  ------result------
  이성진 홍삼캔디 3주압수
  이성진 홍삼캔디 3주압수
  이성진 홍삼캔디 3주압수
  이성진 홍삼캔디 3주압수
  ...계속 나온다
  
  ```

  

- **repret while**구문은 whille 구문이 조건을 만족하지 못해도 적어도 한 번은 실행 블록의 수행을 보장하는 구문이다.

  ```Swift
repeat {
    실행할 구문
  } while 조건식 
  ```
  
  ```swift
  var foo = 0
  
  repeat {
    print ("민석이는 돈이많아요")
    foo += 1
  } while foo < 3
  
  ------result------
  민석이는 돈이많아요
  민석이는 돈이많아요
  민석이는 돈이많아요
  
  ```
  
  

2. 조건문 

   **if**구문은 조건식의 **참과 거짓을 판별**해 분기해주는 많이 사용되는 구문이다. 
   
   ```swift
   if 조건식 {
     조건이 참일경우 실행할 구문
   }
   ```
   
   ```swift
   var foo = 1
   
   if (foo==1) {
     print("배고파요")
   }
   
   ------result------
   배고파요
   
   ```
   
   

- if 문에는 반드시 Bool 타입의 값으로 판단할 수 있는 조건만이 들어가야 한다.

   

- **if~else**구문은 조건식이 **참이 아닐때 실행할 수 있는 구문을 넣을 수 있게** if 문을 확장해주는 구문이다. 

   ```swift
   if 조건식 {
     조건이 참일경우 실행할 구문
   } else {
     조건식이 참이 아닐경우 실행할 구문
   }
   ```

   ```swift
   var foo = 1
   
   if (foo==1) {
     print("참")
   } else {
     print("거짓")
   }
   
   ------result------
   참
   
   ```

   

- if 구문 또한 **여러 개를 중첩해서 사용**할 수 있다.

   ```swift
   var mingi = 0
   var junsang = 0
   
   if (mingi==0) {
     if (junsang==1) {
       print("wow")
     } else {
       print("red pig")
     }
   } else {
     print("diet")
   }
   
   ------result------
   red pig
   
   ```

   

- **if~else if**구문은 **비교할 조건이 여러개일 때 사용**하는 조건식이다.

   ```swift
   if 조건식 {
     조건이 참일경우 실행할 구문
   } else if 조건이 거짓일경우 비교할 다른 조건 {
     조건이 참일경우 실행할 구문
   } else {
     모든 조건이 거짓일때 실행할 구문
   }
   ```

   ```swift
   var foo = 1
   
   if (foo==0) {
     print("foo는 0이에요")
   } else if (foo==1) {
     print("foo는 1이에요")
   } else {
     print("foo가 뭘까요...")
   }
   
   ------result------
   foo는 1이에요
   
   ```

    

- if 문과 비슷한 **guard**구문은 else 문이 필수지만, **조건식이 참일 경우 실행되는 블록이 없다**.

   ```Swift
   guard 조건식 else {
     조건이 거짓일경우 실행할 구문
   }
   ```

   ```swift
   var foo = 0
   
   guard (foo==1) {
     print("Error!!")
   }
   
   ------result------
   Error!!
   
   ```

- 주로**오류 검출**에 사용된다.

- guard 문은 if 문으로 대체 가능하다.

   

- **#available** 구문은 **OS 버전별로 구문을 나누어 특정 OS에서 실행될 때 오류가 일어나는 것을 처리**해주는 역할을 한다. 

   ```swift
   if #available (플랫폼 이름 버전1, 플랫폼 이름 버전2, 플랫폼 이름 버전n *) {
     해당 버전에서 사용할 수 있는 API 구문
   } else {
     API를 사용할 수 없는 환경에 대한 처리
   }
   ```

   

- **switch case** 구문은 입력받은 **값을 패턴으로 비교하고 그 결과를 바탕으로 실행 블록을 결정**하는 조건문이다.

   ```swift
   switch 	비교대상 {
     case 비교패턴1 : 비교패턴1이 일치했을 경우 실행할 구문
     case 비교패턴2 : 비교패턴2가 일치했을 경우 실행할 구문
     case 비교패턴n : 비교패턴n이 일치했을 경우 실행할 구문
     default : 어느 비교 패턴과도 일치하지 않을때 실행할 구문
   }
   ```

   ```Swift
   var foo = 1
   
   switch foo {
     case 1: print("foo는 1")
     case 2: print("foo는 2")
     default: print("foo가 뭐에요?")
   }
   
   ------result------
   foo는 1
   
   ```

- switch 구문에서 패턴이 일치하는 case 구문을 실행하는 대신, 그 다음 case 블록으로 실행 흐름을 전달하는 문법을 **Fall Through**라고 한다. 

- Swift 의 switch 구문에서는 명시해 주지 않아도 적용하기 때문에 **암시적인 Fall Through** 라고 한다. 이덕분에 Swift에서는 Swich 구문에서 **break문을 생략**할 수있다.

- 패턴이 어느 것과도 일치하지 않은 경우를 **switch 문이 실패했다**고 부른다. (따라서 오류 발생, **default문 꼭 필요**)

- case 패턴을 작성할 때, **하나 이상의 비교 패턴을 연이어 작성할 수 있다**. 

   ```swift
   case 비교패턴1, 비교패턴2 : 비교패턴1, 2 가 일치했을 경우 실행할 구문
   ```


 또한 Swift에서는 **switch 문이 부분적으로 일치할 경우 전체가 일치하는것으로 간주**한다. EX)튜플 사용, 범위 데이터



3. 제어 전달문
    - **break**구문은 루프를 조건식의 결과에 상관 없이 강제종료 하는데 사용된다.
    
      ```swift
      var i = 1
      
      for _ in 1...7 {
          print(i)
          if (i==4) {
              break
          }
          i += 1
      }
      
      ------result------
      1
      2
      3
      4
      
      ```
    
    - 중첩된 구문 내에 있는 break문은 **외부 반복문에는 영향을 주지 못한다.**
    
      
    
    - **continue**구문은 이 구문 아래의 실행 구문들을 모두 건너뛰고, 다음 반복 루프를 시작하는데 사용된다.
    
      ```swift
      var i = 0
      
      for _ in 0...7 {
          i += 1
          if (i==4) {
              continue
          }
         print(i)
      }
      
      ------result------
      1
      2
      3
      5
      6
      7
      
      ```
    
      
    
    - 조건문, 반복문 앞에 레이블 이름과 콜론을 붙여 정확히 흐름 제어가 적용 될 수 있게 해주는 **구문 레이블**을 정의할 수 있다.
    
      ```swift
      레이블 이름: 조건 반복문
      ```
    
      ```swift
      let foo = 1
      
      sweet: if(foo==1) {
        print("chocolete")
      }
      ```
    
      
    
    - **fallthrough**구문은 **switch 구문에서 case 블록의 실행을 다음 case 블록으로 전달할 때 사용**한다.
    
      ```swift
      var foo = 1
      
      switch foo {
      case 1:
          print("foo는 1이에요")
          fallthrough
      case 2:
          print("foo는 2에요")
      default:
          print("모르겠어요")
      }
      
      ------result------
      foo는 1이에요
      foo는 2에요
      
      ```
    
      
    
    - **return**구문은 **값을 반환할때 사용**한다.(함수에서 많이 사용)
    
      ```swift
      return 반환할 값
      ```
    
    ==========
# 집단 자료형


1. 배열
    - **배열**은 **일련의 순서를 가지는 리스트 형식의 값을 저장**하는데에 사용되는 **자료형**이다.
    - **배열 안의 값을 순서대로 일련번호 형식으로 나타내는 것**이 **Index**다.
    ### **Index는 0부터 시작한다.**
    
    
    
    - 배열 중간의 값이 삭제되더라도 다른 값들이 앞으로 이동하며 빈 Index를 채워넣는다.
    
      
    
    - 따라서 마지막 인덱스는 배열의 크기보다 항상 1만큼 작다.
    
      
    
    - 배열에 저장할 아이템의 타입에는 제약이 없지만, **하나의 배열에 저장하는 아이템 타입은 모두 같아야 한다.**
    
      
    
    - 배열을 선언해줄 때 배열에 저장할 아이템 타입을 명확히 정의해야 한다.
    
      
    
    - **배열의 크기는 동적으로 확장할 수 있다.**
    
      
    
    - 배열은 **정적** 또는 **동적** 으로 정의할 수 있다.   
    
      ​                    
    
    - 배열을 정적인 방식으로 선언하는법
    
      ```swift
      var 배열 이름 = [데이터1, 데이터2, 데이터n]
      ```
    
      ```swift
      var lunchMenu = ["chicken", "milk", "rice"]
      ```
    
      
    
    - 배열을 **순회 탐색할 때에는 보통 for~in 구문**과 **반 닫힌 범위 연산자**를 많이 사용한다.`
    
    - 배열의 길이를 구할 때에는 배열 변수나 상수에 **.count** 를 붙여주면 된다.
    
      ```swift
      var yellowCity = ["Apdo", "MonsterRat", "Ralo", "Paka"]
      
      print(yellowCity.count)
      
      ------result------
      4
      
      ```




   - 또한 **이터네이터** 를 사용하는 방법이 있다. **for~in 구문에 배열을 넣어주면** 루프 상수에 할당되는 것이다.

     ```swift
     var hiphopLable = ["Ambition", "IMJM", "AOMG"]
     
     for hiphopLable in 0...3 {
       print(hiphopLable)
     }
     
     ------result------
     0
     1
     2
     3
     
     ```



- index(of:) 메소드를 사용해 아이템이 몇 번째 인덱스에 저장되어있는지 알아낼 수 있다.

  ```swift
  var rapper = ["Justhis", "Ash Island", "CHANGMO"]
  
  print(rapper.index(of:"Justhis"))
  
  ------result------
  optional(0)
  
  //여기서 나오는 optional은 뒤에서 다룬다 이를 없애주려면
  //print(rapper.index(of:"Justhis")!)로 고쳐주면 된다고만 알아두자.
  
  ```

  

- 배열이 비었는지 체크할 때에는 메소드 **isEmpty** 를 사용하면 된다. 이 메소드는 **배열이 비어있으면 true, 비어있지 않으면 false를 반환**한다.

  ```swift
  선언 완료된 배열 이름.isEmpty
  ```

  ```swift
  var myGirlfriend = [""]
  
  print(myGirlfriend.isEmpty)
  
  ------result------
  false
  
  ```

- 배열에 값을 동적으로 추가하고 싶을 때

  ```swift
  선언 완료된 배열 이름.append(추가할 데이터)
  ```

- **append(_:)** 메소드는 **배열의 크기를 1만큼 확장하고, 입력된 값을 배열의 맨 뒤에 추가한다.** 

  

  ```swift
  선언 완료된 배열 이름.insert(추가할 데이터, at:원하는 인덱스 위치)
  ```

- **insert(_:at:)** 메소드는 **아이템을 끼어들기 시켜 원하는 위치에 넣을 때 사용된다. at 뒤에 입력되는 정수값은 배열에서 아이템이 추가될 인덱스의 위치를 의미한다.**

  

  ```swift
  선언 완료된 배열 이름.append(contentsOf:[추가할데이터1, 추가할데이터2, 추가할데이터n...])
  ```

- **append(contentsOf:)** 메소드는 **여러 개의 아이템을 배열에 한꺼번에 추가할 때 쓰는 메소드이다.**

  

  ```Swift
  var todayDinner = [""]
  
  todayDinner.append("rice")
  todayDinner.insert("meat", at: 1)
  todayDinner.append(contentsOf: ["kimchi", "nutellaBanana"])
  
  print(todayDinner[0])
  print(todayDinner[1])
  print(todayDinner[2])
  print(todayDinner[3])
  print(todayDinner[4])
  
  ------result------
  
  meat
  rice
  kimchi
  nutellaBanana
  
  ```

  

- **입력된 배열값을 번경하고 싶을 때에는 기존 인덱스에 연결된 아이템을 교체하면 된다.**

  

  ```swift
  var 1학년2반 = ["도현"]
  print(1학년2반)
  
  1학년2반[0] = "용성"
  print(1학년2반)
  
  ------result------
  
  
  ```

  

  

- 단 **없는 인덱스에 배열을 추가할 수는 없다.** 이 경우 **오류가 발생**한다.

- **범위 연산자를 이용하여 인덱스를 참조할 수 있다.**

  `print(1학년2반[0..<2])`

2. 집합 

   **집합**은 **같은 타입의 서로 다른 값을 중복 없이 저장**하고자 할 때 사용되는 **집단 자료형**이다.  

- 주로 **중복 없이 한 번만 저장되어야 하는 데이터를 다룰 때 배열 대신 사용한다.**

- ### **인덱스가 없다.**

- **해시 연산**의 결과값을 이용하여 데이터를 저장하므로, **Hashable 프로토콜을 구현해야 한다.**

- **Set**이란 키워드를 사용하여 정의한다. 

  `var meal : Set = ["시리얼", "우유", "치킨텐더"]`

- 나머지 값으로 사용되는 데이터 리터럴은 배열과 동일하다.

- 빈 배열을 작성하려면 **타입 어노테이션에서 아이템 타입을 작성해야 한다.** 

  `var dinner : Set<String> = ["밥", "국", "음료수"]`

- **isEmpty 메소드 사용 가능하다.**

- 집합과 동일한 방식으로 순회 탐색을 할 수 있다.

- **sorted( )** 메소드를 사용하여 abc순서대로 정렬할 수 있다.

  `dinner.sorted( )`

- 집합에 아이템을 동적으로 추가할 떄에는 **배열과 동일하게 insert(_:) 메소드를 사용**한다.
  
    `dinner.insert("iceCream")`
    
- 다만 **삭제할 때에는 remove(_:)메소드를 사용**한다. 

    - 그러나 **삭제할 값이 집합에 없으면 remove(:_)메소드는 아무것도 삭제하지 않고 nil 을 반환**한다.
    - **contains(_:)** 메소드는 인자값으로 입력된 데이터를 사용하여 **집합 안에 일치하는 데이터가 있는지 없는지 알려준다.**(Bool값으로 알려준다.)

    - **집합끼리는 연산을 할 수 있다.**  EX) arr1.intersection(arr2)

    - **intersection(_:) 메소드는 양쪽에서 공통된 아이템만 선택하여 새로운 집합을 만들어준다.**

    - **symmetric Difference(_:) 메소드는 양쪽에서 어느 한 쪽에만 있는 아이템을 선택하여 새로운 집합을 만들어준다.(공통으로 있는 아이템은 제외)**

    - **union(_:) 메소드는 양쪽 모두에 있는 아이템을 모두 선택해 새로운 집합을 만들어준다.(공통으로 있는 아이템이라고 해서 중복되지 않음)**

    - **subtract(_:) 메소드는 한쪽 집합에 있는 모든 아이템에서 다른쪽 집합에도 속하는 공통 아이템을 제외하고 새로운 집합을 만들어준다.**

    - subtract(_:) 메소드를 제외하고는 양쪽 집합의 위치가 바뀌어도 결과는 동일하다.

    - 또한 포함관계를 판단해주는 연산도 가능하다.

    - **isSubject(of:) 메소드는 주어진 집합의 값 전체가 특정 집합에 포함되는지 여부를 판단하여 Bool 값을 반환해준다.**

    - **isSuperest(of:) 메소드는 주어진 집합이 특정 집합의 모든 값을 포함하는지흫 판단하여 Bool 값을 반환해준다.**

    - **isStrictSubject(of:)와 isStrictSuperset(of:) 메소드는 위의 두 메소드와 같지만, 두 집합이 서로 완전히 같은 경우 결과값을 다르게 반환해준다.(그냥 조금 더 엄격하다 정도..?)**

    - **isDisjoint(with:) 메소드는 두 집합 사이의 공통 값을 확인하여 아무런 공통 값이 없을 때 true, 하나라도 있으면 false를 반환해준다.**

    - 배열을 집합으로 번경한 뒤 다시 배열로 변경해 손쉽게 중복 값 제거가 가능하다,

3. 튜플
    -  **하나의 튜플에 여러가지 타입의 아이템을 저장 가능 하다.**
    - **상수의 성격을 띄어 한번 선언되면 값을 추가하거나 삭제 불가능하다.**
    - **소괄호를 써서 정의한다.** EX) var tp = ("a", "b", 1, 2.2, true)
    - **인덱스를 점으로 표기한다.** EX) tp.0
    - 없는 인덱스를 참조시 오류가 발생한다,
    - 아이템을 개별 변수나 상수로 할당받는 **바인딩**이 가능하다.
    - **순회 탐색이 불가능하다.**
    - 바인딩을 할 때 사용하지 않을 튜플 아이템은 언더바로 대체가 가능하다.
    
4. 딕셔너리
    - **고유 키와 그에 대응하는 값을 연결하여 데이터를 저장하는 자료형이다.**
    - 정의 형식은 **[ 키 : 데이터, 키 : 데이터]** 이런 식으로 정의할 수 있다.
    - **하나의 키는 하나의 데이터에만 연결되어야 한다.**
    - **같은 딕셔너리 내에서 키는 중복될 수 없다.**(중복해서 선언하면 아이템 수정으로 간주.)
    - **데이터 타입엔 제한이 없으나, 하나의 딕셔너리 내에서는 같은 자료형을 사용하여야 한다.**
    - **순회 탐색이 가능하다.**
    - **키의 타입은 해시 연산이 가능해야 한다.**
    - 빈 딕셔너리의 선언은 **Dictionary** 키워드를 통해 할 수 있다. EX) Dictionary <int, string> ( )
    - 이것을 간단한 방식으로 줄이면 **[ 키로 사용할 타입 : 값으로 사용할 타입 ] ( )** 이렇게 선언해줄 수 있다.
    - 딕셔너리 역시 isEmpty 메소드를 사용할 수 있다.
    - **updateValut(_:forKey:)** 메소드를 통해 딕셔너리에 값을 할당할 수 있다. <딕셔너리 객체>.updateValue(<저장할 데이터>, forKey:<데이터를 참조 및 저장하는 데 사용할 키>)
    - **removeValue(forKey:)** 메소드를 통해 딕셔너리에 값을 삭제할 수 있다.
    - ### 딕셔너리에서 키를 호출해서 저장된 값을 불러올 때 **옵셔널** 형태로 반환한다.


=========


# 옵셔널


### **옵셔널 타입**은 **nill** 을 사용할 수 있는 타입을 부르는 말이다.

1. nill
    - **값이 없다** 는 것을 나타내주는 특수한 값이다.
    - nill을 반환하려면 해당 타입이 옵셔널 타입으로 정의되어있어야 한다.
    - **정상적으로 값을 처리하지 못하는 상황이 발생하였을 때 nill을 반환**한다.
    - **자료형에는 nill을 대입할 수 없다.**
    - **옵셔널 타입으로 선언된 자료형에는 nill을 대입할 수 있다.**
    - **모든 기본 자료형 앞에 Optional을 붙이면 옵셔널 타입이 된다.** EX) Optional Int, Optional String
    - Swift 에서 옵셔널 타입이 가질 수 있는 값은 **nill이 아닌 값**과 **nill 값** 두 가지뿐이다.
    - **성공적으로 처리되면 옵셔널로 감싸진 결과값이 반환되고. 문제가 있으면 nill이 반환된다.** EX) Optional(123)
    - ### **옵셔널 타입은 반환하려는 값을 옵셔널로 감싼 형태이다.**
    - 옵셔널로 싸여있는 것을 **옵셔널 래핑** 이라고 하고, 이를 헤제하는 과정을 **옵셔널 언래핑**이라고 한다.

2. 옵셔널 타입 선언, 정의
  
- ### **자료형 뒤에 ? 를 붙인다.**
  
3.  옵셔널 값 처리
    - **옵셔널 언래핑을 해야지만 연산, 대입이 가능하다.**
    - 옵셔널 언래핑의 방법에는 **명시적 해제**와 **묵시적 해제**가 있다.
    - 명시적 해제법에는 **강제 해제**와 **비강제 해제**가 있다.
    - 묵시적 해제법에는 **컴파일러에 의한 자동 해제**와, **! 연산자를 사용한 자동 해제**법이있다.
    - ### **옵셔널 타입의 값 뒤에 !(강제 해제 연산자) 를 붙이면 강제 해제가 된다.**
    - 하지만 **강제 해제 연산자를 사용하였을 때엔 nill 값일때도 강제 해제가 되어 오류가 발생**한다.
    - **옵셔널 바인딩**을 통해 안전하게 해제가 가능하다.
    - 옵셔널 바인딩은 **조건문 내에서 일반 상수에 옵셔널 값을 대입하는 방식**이다.
    - 컴파일러에 의해 옵셔널이 자동으로 해제되는 경우가 있다.(**비교 연산을 처리할 때**)
    - ### **!연산자를 사용해 옵셔널 타입을 선언할 수 있는데 이 때 옵셔널의 묵시적 해제가 일어나 일반 변수처럼 다룰 수 있다.**
    - **이때 변수의 값이 nill이 될 가능성이 있다면 사용해서는 안된다.**
    
    

=========


# 함수


1. 함수의 개념
    - **인자값 또는 파라미터**를 입력받아 **반환값 또는 리턴값**을 내어놓는다.
    - 인자값이 **없을수도**있다.
    - 집단 자료형에 담아서 반환할 수도 있다.
    - **일반 함수**와 **사용자 정의 함수**로 나눌 수 있다.
    - 일반 함수는 기본적인 데이터의 처리나 연산 등을 수행하기 위한 목적으로 사용된다.
    - 사용자 정의 함수는 우리가 원하는 기능들을 실행해줄 함수를 직접 만들어 사용할 수 있는 함수를 말한다.
    - 동일한 코드가 여러 곳에서 사용될 때 이를 함수화하면 재작성할 필요 없이 함수 호출만으로 처리할 수 있다.
    - 전채 프로세스를 하나의 소스 코드에서 연속적으로 작성하는 것보다 기능 단위로 함수화하면 가독성이 좋아지고, 코드와 로직을 이해하기 쉽다.
    - 로직을 번경할때 함수 내부만 수정하면 되므로 유지 보수가 용이하다.
    - 함수는 **func** 키워드로 정의할 수 있다.
    - func 함수이름(매개변수 1: 타입, 매개변수2: 타입, ...) -> 반환타입 {
    실행내용
    return 반환값 }의 형식으로 정의된다.
    -  이떄 **연산자와 예약어는 사용할 수 없다.**
    - 함수의 이름에 사용할 수 있는 문자들은 영어나 숫자, 한자, 바이너리 이미지 등 다양하다.
    - **단 첫글자는 반드시 영어 또는 언더비로 시작해야 한다.**
    - **반환 타입을 생략함으로써 반환값이 없음을 표현할 수 있다.**
    - 처리값을 반환하는 키워드는 **return**이다.
    - 반환값이 없는 함수일 경우에도 **함수의 실행을 명시적으로 종료할 목적으로**사용된다.
    - **함수를 호출할 때에는 함수의 이름에 괄호를 붙이면 실행된다.**
    - 매개변수를 가지고 있는 함수는**괄호 안에 인자값을 넣어서 호출**해야 한다.
    - 매개변수를 가지고 있는 함수는 인자 레이블을 붙여주어야 한다.
    
2. 매개변수 
    - 매개변수는 **내부 매개변수**와 **외부 매개변수**로 나눌 수 있다.
    - 내부 매개변수는 **함수가 내부적으로 인자값을 참조하기 위해 사용하는 변수**이다.
    - 외부 매개변수는 **함수 외부에서 함수나 인자값을 구분하기 위해 사용하는 변수**이다.
    - 외부 매개변수를 명시적으로 정의하면 **외부 매개변수가 인자 레이블이 된다.**
    - 외부 매개변수를 정의하는 방법은 내부 매개변수 앞에 매개변수명을 넣어주기만 하면 된다.
    -  **언더바를 사용하여 외부 매개변수명을 생략할 수 있다.**
    - 매개변수가 **여러개일떄는 일부만 생략 할 수도 있다.**
    - **매개변수명 뒤에 ... 연산자를 붙여 가변적인 개수의 인자값을 받을 수 있다.**
    - 이를 **가변인자**라고 하는데 입력 개수를 특정할 수 없는 형태의 매개변수에 사용된다.
    - for~in문을 이용한 순회 탐색으로 모든 인자값을 순서대로 읽어 들일 수 있다.
    - 매개변수는 **기본값**을 가질 수 있다.
    - 기본값을 입력하는 방법은 **매개변수 타입 다음에 대입 연산자인 = 를 추가하고 기본값을 작성해주면 된다.**
    - **함수에 입력된 인자값은 함수 내부에서 상수로 정의된다.**
    - ### **함수 내부에서 매개변수와 동일한 이름의 변수를 정의하고, 매개변수의 값을 대입해주면 매개변수의 값이 수정된다.**
    - **타입 표현이 들어있던 곳에 inout 키워드를 넣고 타입 변수를 그 뒤쪽으로 밀어내고 & 연산자를 붙여주면 인자값이 할당된 데이터가 저장되어있는 메모리 주소를 함수 내부로 전달해준다.**
    - 함수 외부에서 정의된 변수를 내부에서 가져다 사용하면 inout 키워드를 사용하지 않고도 외부의 변수를 내부에서 바로 참조 가능하다.
    - 프로그램 최상위 레벨에서 작성된 변수를 **전역 변수** 라고 한다.
    - **지역 변수**는 선언된 블록 범위 안에서만 참조할 수 있는 변수이다.
    - 전역 변수는 **모든 블록 내에서 사용 가능** 하지만, 지역변수는 **선언된 블록을 벗어나면 메모리에서 해제되고, 아예 존재하지 않는 변수가 된다.**
    - 함수는 **실행 블록을 가지고 있는 객체**이다.
    - Swift 에서 함수의 외부와 내부에 각각 같은 이름의 변수가 존재하면 내부에서 선언된 변수는 외부와 상관없이 새롭게 생성된다.
    - 이 경우 두 변수는 같은 변수가 아니다.

3. 일급 함수
    - 일급 함수는 **변수나 상수에 함수를 대입할 수 있다.**
    - 이때 **함수의 결과값을 대입하는 것이 아니라, 함수 자체를 대입하는 것이다.**
    - 함수를 대입하는 과정에서 함수가 실행되지는 않는다. **객체 자체만 전달된다.**
    - 함수가 대입된 변수나 상수를 함수처럼 호출하면 그때 함수가 실행된다.
    - 변수에 함수를 대입하면 **함수 타입**이 된다.
    - **( 인자 타입1, 인자 타입2, ... ) -> 반환 타입** 의 형식으로 작성해주면 된다.
    - ### **함수 정의 구문에서는 반환 타입을 생략할 수 있지만, 함수 타입에서는 Void라고 명시해 주어야 한다.**
    - **Void**는 빈 튜플을 나타내는 값으로, 타입알리어스로 정의된 단어이다. **(객체가 아니라 키워드이다.)**
    - 일급 함수는 **함수의 반환 타입으로 함수를 사용할 수 있다.**
    - 일급 함수는 **함수의 인자값으로 함수를 사용할 수 있다.**
    - **콜백 함수**는 특정 구문의 실행이 끝나면 시스템이 호출하도록 처리된 함수이다.
    - 이런식으로 중계 역할을 하는 함수를 **브로커**라고 한다.
    - **defer** 구문은 함수나 메소드에서 코드의 흐름과 상관없이 가장 마지막에 실행되는 블록이다.
    - **지연 블록** 이라고도 불리는데 이 블록에 작성된 구문은 작성된 위치에 상관없이 항상 함수의 종료 직전에 실행되므로 종료 시점에 맞추어 처리하려는 구문이 있을 떄 유용하게 사용된다.
    - defer 블록의 특성은 다음과 같다.
    - 함수가 종료되기직전에 실행된다.
    - defer 블록을 읽기 전에 함수의 실행이 종료될 경우 defer 블록은 실행되지 않는다.
    - 하나의 함수나 메소드 안에서 defer 블록을 여러 번 사용할 수 있다. 이때 **가장 마지막에 작성된 defer 블록부터 역순으로 실행된다.**
    - defer 블록은 중첩해서 사용이 가능하다. 이떄 **가장 바깥쪽에 defer 블록부터 실행된다.**
    - Swift 에서도 익명 일회성 함수인 **클로저**를 지원한다.
    - Swift 에서는 함수를 중첩해서 작성할 수 있다. 이렇게 작성된 함수를 **중첩 함수**라고 한다.
    - 이때 함수 내에 작성된 함수를 **내부 함수**, 밖에 작성된 함수를 **외부 함수**라고 한다.
    - 내부 함수를 외부 함수의 실행과 종료 사이에서 생겼다가 사라진다.
    - 내부 함수는 외부 함수를 거치지 않으면 접근할 수 없다. 이를 이용해 함수의 은닉성을 높일 수 있다.
    - 다음은 클로저에 대한 설명이다.
    - 클로저는 두 가지로 이루어진 객체이다. 하나는 **내부 함수**이며, 또 다른 하나는 **내부 함수가 만들어진 주변 환경**이다.
    - 클로저는 외부 함수 내에서 내부 함수를 **반환**하고, **내부 함수가 외부 함수의 지역 변수나 상수를 참조할 때 만들어진다.**
    - 클로저를 요약하자면 **내부 함수와 이 함수를 둘러싼 주변 객체들의 값을 함꼐 의미하는 것**이다.
    
4. 클로저
    - Swift 에서 클로저라고 부르는 객체는 대부분 다음 세 가지 경우 중 하나이다.
    - 전역함수 : 이름이 **있으며**, **주변 환경에서 캡처할 어떤 값도 없는 클로저**
    - 중첩함수 : 이름이 **있으며**, **자신을 둘러싼 함수로부터 값을 캡처할 수 있는 클로저**
    - 클로저 표현식 : 이름이 **없으며**, **주변 환경으로부터 값을 캡처할 수 있는 경량 문법으로 작성된 클로저**
    - 클로저 표현식은 함수와 달리 **생략되는 부분이 많다.**
    - **func 키워드, 이름을 생략한다.**
    - **{(매개변수) -> 반환 타입 in 실행할 구문 }** 의 형태로 쓰인다.
    - **반환값이 없는 경우 이를 명시적으로 Void를 이용해 표현할 수 있다.**
    - **클로저 표현식은 그 자체로 함수라고 할 수 있다.**
    - 클로저 표현식은 대부분 **인자값으로 함수를 넘겨주어야 할 때 사용된다.** 하지만 직접 실행해볼수있는 두 가지 방법이 있다.
    - **일급 함수로써의 특성을 활용하여 상수나 변수에 클로저 표현식을 할당하고 실행하는 방식**이 있다.
    - 클로저 표현식을 할당받을 상수까지 생략하고 싶다면, **클로저 표현식 전체를 소괄호로 감싸고, 여기 함수 호출자를 붙히면 클로저 표현식이 실행된다.**
    - 이때 **전체를 감싸지 않으면 오류를 발생시킨다.**
    - 매개변수가 있는 클로저 표현식은 앞에서 작성한 구문에 **매개변수와 함수의 이름만 작성해주면 된다.**
    - **트레일링 클로저**는 함수의 마지막 인자값이 클로저일 때 이를 인자값 형식으로 작성하는 대신 함수의 뒤에 꼬리처럼 붙일 수 있는 문법이다.
    - **이때 인자 레이블은 생략된다.**
    - **클로저를 인자값으로 받더라도, 마지막 인자값이 아니면 적용할 수 없다.**
    - 인자값이 하나일 때에는 인자값을 넣어주기 위한 괄호도 생략 가능하다.
    - **@escaping** 메소드는 인자값으로 전달된 클로저를 저장해 두었다가 나중에 다른 곳에서도 실행 할 수 있도록 허용해주는 메소드이다.
    - Swift 에서 함수의 인자갑승로 전달된 클로저는 **함수 내에서 직접 실행을 위해서만 사용**해야 한다.
    - 따라서, 함수 내부에서도 변수나 상수에 대입할 수 없다.
    - **@autoclosure** 속성은 인자값으로 전달된 일반 구문이나 함수 등을 클로저로 **래핑**해준다.
    - 이 속성을 적용하면 인자값을 **( )** 형태로 사용할 수 있다.
    - ### **클로저를 경량화하여 간단하게 표현할 수 있다.**
    - **@autoclosure** 속성을 사룔할 경우에 인자값은 코드에 작성된 시점이 아닌, 클로저가 실행되는 시점에 맞추어 실행되며, 이를 **지연된 실행**이라고 부른다.
    - ### 클래스나 구조체 내부에 정의된 함수를 **메소드**라고 한다.


=========


# 구조체와 클래스


- 구조체와 클래스 내부에서 정의된 변수와 상수를 **프로퍼티**라고 한다.
- 메소드와 프로퍼티를 합쳐서 구조체나 클래스의 **멤버**라고 표현한다.
- 구조체와 클래스의 공통점은 다음과 같다.
- **변수나 상수를 사용하여 값을 저장하는 프로터피를 정의할 수 있다.**
- **함수를 사용하여 기능을 제공하는 메소드를 정의할 수 있다.**
- **속성값에 접근할 수 있는 서브스크립트를 정의할 수 있다.**
- **객체를 원하는 초기 상태로 설정해주는 초기화 구문을 사용할 수 있다.**
- **객체에 함수적 기능을 추가하는 확장구문을 사용할 수 있다.**
- **특정 형식의 함수의 표준을 제공하기 위한 프로토콜을 구현할 수 있다.**
- 구조체는 할 수 없지만, 클래스는 할 수 있는 기능은 다음과 같다.
- **클래스의 특성을 다른 클래스에게 물려줄 수 있다.**
- **실행 시 컴파일러가 클래스 인스턴스의 타입을 미리 파악하고 검사할 수 있다.**
- **인스턴스가 소멸되기 직전에 처리해야 할 구문을 미리 등록해 놓을 수 있다.**
- **클래스 인스턴스가 전달될 때에는 참조 형식으로 제공되며, 이떄 참조가 가능한 개수는 제약이 없다.**

1. 구조체와 클래스의 기본개념
    - 구조체와 클래스는 정의하는 구문이 비슷하다.
    - 구조체는 **struct** 키워드를 사용한다.
    - 클래스는 **class** 키워드를 사용한다.
    - 둘 다 **키워드 다음 객체의 이름을 선언해주고, 객체 정의 내용을 중괄호로 감싸주면 된다.**
    - 객체의 이름을 작성할 때에는 표준 Swift 객체 코딩 형식에 따라 
    - **객체의 이름의 첫 글자는 대문자, 나머지는 소문자로 작성한다.** 
    - **두개 이상의 복합 단어로 이루어질 경우 단어별로 끊어 첫 글자는 대문자, 나머지 글자는 소문자로 작성한다.**
    - **이미 축약된 약어는 모두 대문자로 작성 가능하다.**
    - **프로퍼티나 메소드를 선언할 때에는 소문자로 시작한다.**
    - **언더바로 단어를 연결하는 방식은 지양한다.**
    - 이를 **카멜 표기법**이라고 한다.
    - 구조체와 클래스에서는 프로퍼티를 정의하여 **내부적인 값을 저장**할 수 있다.
    - 또한 메소드를 정의하여 **특정 기능을 정의**할 수 있다.
    - EX) class Menu { var rice : String = ""  var noodle : String ="" }
    - ### **프로퍼티는 초기값이 할당되지 않았을때 자동으로 nil값으로 초기화된다.**
    - 구조체나 클래스는 실행할 수 있는 객체를 만들어주는 일종의 **틀**이다.
    - 이때 틀을 이용하여 찍어낸 그릇을 **인스턴스**라고 한다.
    - **인스턴스에 실질적인 값을 담을 수 있다.**
    - 인스턴스를 생성하는 가장 간단한 방식은 **구조체와 클래스의 이름 뒤에 빈 괄호를 붙이는 것이다.**
    - **프로퍼티에 접근하려면 반드시 인스턴스를 먼저 생성해 주어야 한다.**
    - 또한 프로퍼티에 접근할 때에는 반드시 **점 문법**을 통해서 인스턴스의 하위 객체에 접근할 수 있다.
    - 점을 이용하여 인스턴스의 하위 객체에 접근할 때에는 **인스턴스 이름 바로 뒤에 점을 쓰고 그 뒤에 프로퍼티의 이름을 작성한다.**
    - 이때 **점 앞과 뒤에는 공백이 존재하면 안된다.**
    - 만약 서브 프로퍼티를 가지고 있는 객체라면, **점 구문을 사용하여 단계적으로 접근이 가능하다.**
    - 점 구문은 **프로퍼티에 값을 집어넣을때도 사용된다.**
    - EX) Menu.rice = "카레"
    - 단계적으로 점 구문을 연결하는 것을 **체인**이라고 한다.
    - 필요에 따라서는 인스턴스를 만들 때 빈 괄호가 아니라 인자값을 넣어주기도 한다.0.
    - 이때 입력되는 인자값들은 대부분 객체의 프로퍼티를 **초기화** 하기 위해 필요한 것이다.
    - **Swift 에서 옵셔널 타입으로 선언되지 않은 모든 프로퍼티는 명시적으로 초기화해주어야 한다.**
    - 옵셔널 타입으로 선언된 프로퍼티는 초기값이 지정되지 않을 경우 자동으로 **nil값으로 초기화**된다.
    - 구조체는 모든 프로퍼티의 값을 인자값으로 입력받아 초기화하는 기본 초기화 구문을 자동으로 제공한다. 이를 **멤버와이즈 초기화 구문**이라고 한다.
    - 그냥 단순히 괄호만 붙이는 구문을 **기본 초기화 구문**이라고 한다.
    - 프로퍼티와 초기화 구문에 대한 가급적 지키면 좋은 원칙은 다음과 같다.
    - **모든 프로퍼티는 정의할 때 초기값을 주던가, 아니면 옵셔널 타입으로 선언한다.**
    - **인스턴스를 생성할 때에는 클래스명 뒤에 ( )를 붙여준다.**
    - Swift 에서 모든 구조체는 값 타입이다.
    - 구조체를 인스턴스에 대입하면 기존의 인스턴스가 그대로 대입되는 것이 아니라 이를 **복사한 값이 대입**되는 것이다.
    - 클래스는 값을 복사해 전달하지 않고, **메모리 주소 참조에 의한 방식으로 전달한다.**
    - Swift 에서는 여러가지 문제가 생성되는 것을 막기 위해서 **ARC**라는 **클래스 인스턴스를 참조하는 곳이 몇 군데인지 자동으로 카운트해주는 객체**가 있다.
    - 이 객체는 **인스턴스가 변수나 상수, 함수의 인자값으로 할당되면 카운트를 1 증가시키고, 해당 변수나 상수들이 종료되면 카운트를 1 감소시킨다.**
    - 클래스 인스턴스의 비교 연산자는 **==** 연산자와, **!==** 연산자가 있다.
    - 일반적으로 다음 조건에 하나 이상 해당되는 경우라면 구조체를 사용하는 것이 좋다.
    - **서로 연괸된 몇 개의 기본 데이터 타입들을 캡슐화해서 묶는 것이 목적일 때**
    - **캡슐화된 데이터에 상속이 필요하지 않을 때**
    - **캡슐화된 데이터를 전달하거나 할당하는 과정에서 참조 방식보다는 값이 복사되는 것이 합리적일 때**
    - **캡슐화된 원본 데이터를 보존해야 할 때**

2. 프로퍼티
    - 프로퍼티를 우리말로 번역하면 속성이다.
    - 프로퍼티는 **값을 저장하기 위한 목적으로 클래스나 구조체 내에서 정의된 변수나 상수**이다.
    - 프로퍼티가 하는 역할은 **구조체나 클래스에서 값을 제공하는것**이다.
    - 프로퍼티는 값에 대한 저장 여부를 기준으로 두 가지 종류로 나눌 수 있다.
    - 이를 **저장 프로퍼티**와 **연산 프로퍼티**라고 한다.
    - 저장 프로퍼티의 차이는 다음과 같다.
    - 저장 프로퍼티
    - **입력된 값을 저장하거나 저장된 값을 제공하는 역할**
    - **상수 및 변수를 사용해서 정의 가능**
    - **클래스와 구조체에서는 사용이 가능하지만, 열거형에서는 사용 불가능**
    - 연산 프로퍼티
    - **특정 연산을 통해 값을 만들어 제공하는 역할**
    - **변수만 사용해서 정의 가능**
    - **클래스, 구조체, 열거형 모두에서 사용 가능**
    - 인스턴스에 소속되는 프로퍼티를 **인스턴스 프로퍼티**라고 한다.
    - 클래스와 구조체 자체에 소속되어 값을 가지는 프로퍼티들을 **타입 프로퍼티**라고 한다.
    - 타입 프로퍼티는 **인스턴스를 생성하지 않아도 사용할 수 있다.**
    - 프로퍼티는 **클래스의 내부에**, **메소드의 외부에** 정의해야 한다.
    - Swift 에서는 값을 모니터링 하기 위해 **프로퍼티 옵저버**를 정의하여 특정 액션과 반응하도록 처리할 수 있다.
    - 프로퍼티 옵저버는 **우리가 정의한 저장 프로퍼티에 추가**할수 있으며, **슈퍼 클래스로부터 상속 받은 서브클래스에서도 추가** 할 수 있다.
    - init 구문을 사용하여 초기화를 할 때 클래스에서 선언된 프로퍼티나 메소드는 앞에 **self**키워드를 붙여서 구분해 주는 것이 좋다.
    - **옵셔널 타입으로 프로퍼티를 선언한 경우 자동으로 초기화된다.**
    - 저장 프로퍼티는 다음 두 가지로 나눌 수 있다.
    - **var 키워드로 정의되는 멤버 변수**
    - **let 키워드로 정의되는 멤버 상수**
    - **인스턴스를 상수에 할당하면 구조체 내에서 저장 프로퍼티를 변수로 정의했더라도 값을 번경할 수 없다.**
    - **하지만 클래스 내에서는 값을 번경할 수 있다.**
    - 저장 프로퍼티 앞에 **lazy** 키워드가 붙으면 프로퍼티가 호출되는 순간에 초기화된다. 이를 **지연 저장 프로퍼티** 라고 한다.
    - **클로저를 이용하여 저장 프로퍼티를 초기화할 수 있다.** EX) let/var 프로퍼티명: 타입 = { 정의 내용 return 반환값 } ( ) 
    - **이렇게 정의된 클로저 구문은 클래스나 구조체의 인스턴스가 생성될 때 함께 실행되어 초기값을 반환하고, 이후로는 해당 인스턴스 내에서 재실행되지 않는다.**
    - 이때 lazy 구문을 사용하여 메모리 자원을 아낄 수 있다.
    - 연산 프로퍼티는 **get** 구문을 사용하여 값을 제공해준다. 또한 **set** 키워드를 선택적으로 사용하여 값을 할당하거나 번경할수 있다.
    - get, set 구문 사용법 **var 프로퍼티명 : 타입 { get { 필요한 연산 과정 return 반환값 } set(매개변수명) { 필요한 연산 구문 } }**
    - set 구문이 없으면 읽기만 가능하고 쓰기는 불가능한 프로퍼티인 **읽기 전용 프로퍼티**가 된다.
    - 프로퍼티 옵저버의 종류는 다음과 같다.
    - **wilSet** 프로퍼티의 값이 번경되기 직전에 호출되는 옵저버
    - **didSet** 프로퍼티의 값이 번경된 직후에 호출되는 옵저버
    - 이 값을 사용하기 위해서는 wilset 구현 블록 내에서 사용할 이름을 부여할 수 있다. 이름을 부여하지 않았을 때는 **newValue**라는 이름으로 전달된다. ( didSet 구문일 경우 **oldValue** )
    - 옵저버 정의 구문 **var 프로퍼티명 : 타입 [ = 초기값  ] { wilset/didSet  ( 인자명 ) { 프로퍼티 값이 번경되기 전/후에 실행할 내용 } }**
    - 인스턴스를 생성하지 않고 클래스나 구조체 자체에 값을 저장하는 것을 **타입 프로퍼티**라고 한다.
    - **타입 프로퍼티의 값은 모든 인스턴스가 공통으로 사용한다.**
    - 타입 프로퍼티를 선언하는 방법은 클래스나 구조체의 정의 블록 내에서 타입 프로퍼티로 사용할 프로퍼티 앞에 **static**키워드만 추가해주면 된다.
    - 타입 프로퍼티는 **반드시 클래스나 구조체 또는 열거형과 함께 사용해야 한다.**
    
3.  메소드
    - 메소드는 일종의 **함수이다.**
    - 메소드는 **특정 타입의 객체 내부에서 사용하는 함수**이다.
    - 메소드는 **인스턴스 메소드**와 **타입 메소드**로 구분된다.
    - **인스턴스 메소드는 객체의 인스턴스를 생성해야 사용할 수 있는 캡슐화된 메소드이다.**
    - **타입 메소드는 객체의 인스턴스를 생성하지 않아도 사용할 수 있는 객체 타입 자체에 관련된 메소드이다.**
    - 인스턴스 메소드는 객체 타입 내부에 선언된다는 점을 제외하고는 일반 함수와 선언하는 방식이 완전히 동일하다.
    - 또한 인스턴스 없이 독립적으로 호출될 수 없다.
    - 인스턴스 메소드가 일반 함수와 다른 점은 다음과 같다.
    - **구조체와 클래스의 인스턴스에 소속된다.**
    - **메소드 내에서 정의된 변수와 상수 뿐만 아니라 클래스 번위에서 정의된 프로퍼티도 모두 참조할 수 있다.**
    - **self 키워드를 사용할 수 있다.**
    - ### **프로퍼티와 일반 변수의 이름이 충돌할 경우에는 프로퍼티 앞에 반드시 self 키워드를 붙여주어야 한다,**
    - 인스턴스 메소드를 호출할 때에는 **점 구문을 사용하여 호출**한다.
    - 인자값이 있는 메소드를 호출할 떄에는 **호출 시 인자 레이블을 붙여 주어야 한다.**
    - 인자 레이블을 사용하고 싶지 않다면 외부 매개변수명 자리에 언더바를 붙이면 된다.
    - **타입 메소드**는 인스턴스에 의해 호출되는 메소드로서, 반드시 인스턴트를 통해서만 호출 가능하다.
    - 두개의 인스턴스를 생성하여 메소드를 실행하면 해당 인스턴스에만 국한되고, 나머지 인스턴스에는 영향을 주지 않는다.
    
4. 상속
    - ### **한 클래스가 다른 클래스에서 정의된 프로퍼티나 메소드를 물려받아 사용하는 것**을 **상속**이라고 한다.
    - 프로퍼티를 물려주는 클래스와 이를 상속받는 클래스 사이에는 다음과 같은 관계가 성립한다.
    - **프로퍼티와 메소드를 물려받은클래스는 부모 클래스 = 상위 클래스 = 슈퍼 클래스 = 기본 클래스**
    - **프로퍼티와 메소드를 물려받은 클래스는 자식 클래스 = 하위 클래스 = 서브 클래스 = 파생 클래스**
    - 어떤 클래스도 상속받지 않는 클래스를  **기본 클래스**라고 부른다.
    - **클래스를 상속받아 새로운 클래스를 정의하는 것**을 **서브클래싱**이라고 한다,
    - 서브클래싱을 위한 문법 구조 class 클래스 이름 : 부모 클래스 { 추가로 구현할 내용 }
    - **Swift 에서는 다중 상속을 지원하지 않는다.**
    - **자식 클래스에서 재정의 된 메소드나 프로퍼티는 부모 클래스로부터 물려받은 내용을 덮어쓰게되는데** 이를 **오버라이딩**이라고 한다.
    - 오버라이딩한 내용은 **자기 자신 또는 자신을 서브클래싱한 하위 클래스에만 적용**된다.
    - **Swift에서는 오버라이딩 하려는 메소드나 프로퍼티의 선언 앞에 override 키워드를 붙여야 한다.**
    - 오버라이딩을 하면서 override 키워드를 붙이지 않았다면 또는 부모 클래스를 탐색했을때 상속받으려 하는 프로퍼티나 메소드를 찾을 수 없다면 또는 오버라이딩이 아님에도 override 키워드를 붙이는 경우에 오류를 발생시킨다.
    - **연산 프로퍼티로 오버라이딩할 경우 get set 구문을 모두 제공해야 한다.**
    - 프로퍼티 오버라이딩 시 허용되는 것은 다음과 같다.
    - **저장 프로퍼티를 get, set 구문이 모두 있는 연산 프로퍼티로 오버라이딩 하는 것.**
    - **get, set 구문이 모두 제공되는 연산 프로퍼티를 get, set 구문이 모두 제공되는 연산 프로퍼티로 오버라이딩 하는 것.**
    - **get 구문만 제공되는 연산 프로퍼티를 get, set 구문이 모두 제공되는 연산 프로퍼티로 오버라이딩 하는 것.**
    - **get 구문만 제공되는 연산 프로퍼티를 get 구문만 제공되는 연산 프로퍼티로 오버라이딩 하는 것.**
    - 프로퍼티 오버라이딩 시 허용되지 않는 것은 다음과 같다.
    - ### **저장 프로퍼티를 저장 프로퍼티로 오버라이딩 하는 것.**
    - **get, set 구문과 관계없이 연산 프로퍼티를 저장 프로퍼티로 오버라이딩 하는 것.**
    - **저장 프로퍼티를 get 구문만 제공되는 읽기 전용의 연산 프로퍼티로 오버라이딩 하는 것.**
    - **get, set 구문을 모두 제공하는 연산 프로퍼티를 get 구문만 제공되는 연산 프로퍼티로 오버라이딩 하는 것.**
    - 상속받은 프로퍼티를 오버라이딩 하는 과정에서 필요에 따라 프로퍼티 옵저버를 붙일 수 있다.
    - 메소드 오버라이딩에서는 **오버라이딩 대상이 되는 메소드의 매개변수 개수나 타입 순서 그리고 반환 타입은 번경할 수 없다.**
    - 메소드 오버라이딩을 통해 번경할 수 있는 것은 **오로지 내부 구문 뿐**이다.
    - **Swift 에서 메소드는 이름뿐만 아니라 매개변수의 개수와 타입을 기준으로 하여 유일성 여부를 판단한다.**
    - **오버로딩** 문법은**매개변수의 변화만으로 새로운 메소드를 만들어 적재할수 있도록 지원**하는 문법이다.
    - **오버라인된 메소드나 프로퍼티는 해당 클래스를 상속받는 모든 자식 클래스에 적용된다.**
    - **이는 적용된 자식 클래스를 다시 서브클래싱 했을 때도 적용된다.**
    - **하지만 부모 클래스는 오버라이딩의 영향을 받지 않는다.**
    - **super 라는 객체와 점 구문을 이용하면 부모 클래스의 인스턴스를 참조할 수 있다.** EX) super.className( )
    - **Swift 에서는하위 클래스에서 오버라이딩 되는 것을 차단할수 있도록 final 키워드를 제공한다.**
    - **final 키워드를 사용하는 방법은 프로퍼티나 메소드를 정의하는 키워드 앞에 final 키워드를 붙여주면 상수적인 성격이 되어 더는 오버라이드 할 수 없게 된다.**
    - 또한 final 키워드는 클래스 자체에 붙일 수 있다. 이 경우 인스턴스는 만들어 사용할 수 있다.
    - 일부 개발자들이 라이브러리를 배포하기 전에 final 키워드를 붙여 확장을 막는데 사용한다고 한다..
    
5. 타입 캐스팅
    - **자식 클래스는 본래의 타입 대신 부모 클래스 타입으로 선언하여 사용할 수 있다.**
    - **상속 관계에 있는 클래스일 경우 부모 클래스 또는 상위 클래스 타입의 변수나 상수에 인스턴스를 할당하는 것은 허용되지만, 그 반대는 일반적으로 성립하지 않는다.**
    - **Swift 는 타입 비교 연산자 is 를 지원한다.**
    - **타입 비교 연산자는 타입이 일치하는지 여부를 비교하고 그 결과를 Bool 형태로 돌려준다.**
    - 타입 비교 연산자를 사용하는법 **인스턴스( 또는 변수, 상수 ) is 비교대상 타입**
    - is 연산자는 다음과 같은 법칙을 따른다.
    - **연산자 왼쪽 인스턴스의 타입이 연산자 오른쪽 비교대상 타입과 일치할 경우 - true**
    - **연산자 왼쪽 인스턴스의 타입이 연산자 오른쪽 비교 대상 타입의 하위 클래스일 경우 - true**
    - **그 외 - false**
    - **타입 비교 연산자는 변수의 선언 타입이 아니라 그 안에 대입된 실제 값의 타입을 비교한다.**
    - **타입 캐스팅**은 **형변환**을 의미한다.
    - 타입 캐스팅은 **업 캐스팅**과 **다운 캐스팅**으로 나누어진다.
    - 업 캐스팅
    - **하위 클래스 타입을 상위 클래스 타입으로 변환할때**
    - **캐스팅하기 전 타입이 하위 클래스, 캐스팅한 후 타입이 상위 클래스일 때**
    - **캐스팅한 결과, 캐스팅하기 전 타입보다 추상화될 때**
    - **일반적으로 캐스팅 과정에서 오류가 발생할 가능성이 없음**
    - 다운 캐스팅
    - **상위 클래스 타입을 하위 클래스 타입으로 캐스팅할때**
    - **캐스팅하기 전 타입이 상위 클래스, 캐스팅한 후 타입이 하위 클래스일 때**
    - **캐스팅한 결과, 캐스팅하기 전 타입보다 구체화될 때**
    - **캐스팅 과정에서 오류가 발생할 가능성이 있음**
    - **오류에 대한 처리 방식에 따라 옵셔널 캐스팅과 강제 캐스팅으로 나누어짐**
    - 타입 캐스팅을 위한 연산자는 **as** 이다.
    - as 연산자의 사용법은 다음과 같다.
    - 업캐스팅 시 **객체 as 변환할 타입**
    - 다운 캐스팅 시 **객체 as? 변환할 타입( 결과는 옵셔널 타입 )** / **객체 as! 변환할 타입( 결과는 일반 타입 )**
    - **타입 캐스팅을 수행할 때 일반적으로 상속 관계에 있는 클래스들끼리만 캐스팅할 수 있다.**
    - 상속 관계에 있지 않아도 캐스팅할 수 있는 예외가 있는데, **Any**와 **AnyObject** 타입을 사용할 때이다.
    - Any와 AnyObject는 무엇이든 다 받아들일 수 있는 일종의 범용 타입이다.
    - AnyObject 는 **클래스의 일종**으로, **모든 종류의 클래스 타입을 저장**할 수 있다.
    - Any 는 클래스에 국한되지 않고 **Swift 에서 제공하는 모든 타입을 허용**한다.
    - **Any 타입에 할당된 객체가 사용할 수있는 프로퍼티나 메소드는 제공되지 않는다.** 즉 남용하면 안된다.

6. 초기화 구문
    - **모든 저장 프로퍼티는 인스턴스 생성 과정에서 초기화되어야 한다.**
    - 기본 초기화 구문은 위에서 살펴본 대로 객체의 이름 뒤에 괄호를 붙여주는 것이다.
    - **기본 구문 이외의 형식으로 원하는 인자값을 전달하여 저장 프로퍼티를 초기화하기 위해 그에 맞는 형태와 할 일을 미리 정의해두는것** 을 **초기화 메소드** 또는 **생성자**라고 부른다.
    - init 초기화 메소드의 사용 방식 **init ( 매개변수 : 타입, 매개변수 : 타입, ...) { 매개변수의 초기화, 인스턴스 생성 시 기타 처리할 내용 }**
    - Swift 에서 초기화 메소드는 다음과 같은 몇 가지 특성을 지닌다.
    - **초기화 메소드의 이름은 init 으로 통일된다.**
    - **매개변수의 개수, 이름, 타입은 임의로 정의할 수 있다.**
    - **매개변수의 이름과 개수, 타입이 서로 다른 여러 개의 초기화 메소드를 정의할 수 있다.**
    - **정의된 초기화 메소드는 직접 호출되기도 하지만, 대부분 간접적으로 인스턴스 생성 시에 호출된다.**
    - **매개변수는 인스턴스 생성 시 인자 레이블로 사용된다.**
    - **초기화 메소드 역시 인자 레이블을 언더바를 이용해 생략 가능하다.**
    - **init 메소드가 작성되고 나면, 작성된 init 메소드가 어떤 인자값 형식을 갖는가에 상관없이 그 객체의 기본 초기화 구문은 더는 제공되지 않는다.**
    - 기본 초기화 구문을 작성하려면 직접 init( ) 메소드를 정의해 주어야 한다.
    - 인자값이 있는 init 메소드에서 매개변수에 기본값을 지정하면 다음 두 가지 형태의 인스턴스 생성 형식이 만들어진다.
    - **클래스 이름( )**
    - **클래스 이름 ( 프로퍼티 : )**
    - **이는 구조체의 멤버와이즈 구문에도 동일하게 적용된다.**
    - **초기화 구문도 자식 클래스에서 오버라이딩 할 수 있다.**
    - ### **초기화 구문을 오버라이딩하면 더 이상 부모 클래스에서 정의한 초기화 구문이 실행되지 않는다.**
    - 부모 클래스에서 정의된 초기화 구문을 내부적으로 호출할 때에는 초기화 구문 내에 **super.init( )** 구문을 작성하면 된다.
    - 연쇄적으로 자식 클래스의 초기화 구문에서 부모 클래스의 초기화 구문에 대한 호출이 발생하는 것을 **초기화 구문 델리게이션** 이라고 한다.
    - **부모 클래스에 기본 초기화 구문만 정의되어 있거나 기본 초기화 구문이 아예 명시적으로 정의되어있지 않은 상태에서 자식 클래스가 오버라이딩할때는 super.init( ) 구문을 호출해주지 않아도 자동으로 부모 클래스의 초기화 구문이 호출된다.**
    - **부모 클래스에 기본 초기화 구문 외에 다른 형식의 초기화 구문이 추가되어 있다면, 자식 클래스에서 기본 초기화 구문을 오버라이딩할 때 명시적으로 부모 클래스의 기본 초기화 구문을 호출해야 한다.**

7. 옵셔널 체인
    - **클래스나 구조체의 인스턴스가 옵셔널 타입으로 선언될 경우 프로퍼티나 메소드를 소유하는데, 이때 클래스나 구조체의 인스턴스가 옵셔널 타입으로 선언될 경우 프로퍼티와 매소드를 호출하기 위해서는 매번 if 구문을 통해 정상값 여부를 검사해야 한다.**
    - 이떄 옵셔널 비강제 해제 구문을 사용할 수 있다.
    - **강제 해제 연산자를 사용하여 옵셔널 타입을 해제할 수 있지만 너무 많은 위험요소를 내포한다.**
    - **옵셔널 체인**은 옵셔널 타입으로 정의된 값이 하위 프로퍼티나 메소드를 가지고 있을 때, 이 요소들을 if 구문을 쓰지 않고도 간결하게 사용할 수 있는 코드를 작성하기 위해 도입되었다.
    - 옵셔널 체인은 **객체가 nil인 상황에서 안전성 검사를 하지 않고도 메소드나 프로퍼티를 호출하더라도 오류가 발생하지 않을 수 있는 문법을 옵셔널 스타일로 구현한다.**
    - ### **옵셔널 타입을 참조할 때에 옵셔널 타입의 객체 바로 뒤에 ? 연산자를 붙여주면 된다.**
    - **여러 객체가 계층적으로 연결되어 있을 때에도 점 구문 을 사용하며 옵셔널 타입의 객체마다 ? 연산자를 붙여주면 된다.**
    - **이때 오류는 절대 발생하지 않는다.**
    - 일반적으로 옵셔널 체인에는 다음과 같은 특징이 있다.
    - **옵셔널 체인으로 참조된 값은 무조건 옵셔널 타입으로 반환된다.**
    - **옵셔널 체인 과정에서 옵셔널 타입들이 여러 번 겹쳐 있더라도 중첩되지 않고 한 번만 처리된다.**
    - **옵셔널 체인으로 처리된 값은 그 과정에서 몇 번의 옵셔널 체인이 반복되더라도 하나의 옵셔널 객체로만 반환된다.**
    
    

=========


# 열거형과 익스텐션

1. 열거형의 기본 개념
    - **열거형은 하나의 주제로 연관된 데이터들이 멤버로 구성되어 있는 자료형 객체를 말한다.**
    - **열거형에서 데이터들은 열거형 객체를 정의하는 시점과 함께 정의된다.**
    - **따라서 컴파일러가 미리 인지하는것 이 가능하다.**
    - **이는 런타임 오류를 컴파일 오류로 전환해주는 것이 가능하여 안전성을 높여준다.**
    - 다음 상황일 경우 집단 데이터 타입보다 열거형 객체를 정의해 사용하는 것이 훨씬 좋다.
    - **원치 않는 값이 잘못 입력되는 것을 막고 싶을 때**
    - **입력받을 값을 미리 특정할 수 있을 때**
    - **제한된 값 중에서만 선택할 수 있도록 강제하고 싶을 때**
    - **열거형의 멤버로 정의할 수 있는 데이터 집합은 연속된 값들이 아닌 불연속된 값들의 집합이여야 한다.**
    - **또한 종류가 무한히 늘어나지 않고 몇 가지로 수렴되는 값들이어야 한다.**
    - 열거형으로 정의할 수 있는 데이터 집합의 예는 다음과 같다.
    - **성별**
    - **국가**
    - **지역**
    - **직급**
    - **색상**
    - **방향**

2. 열거형의 정의
    - Swift 에서 열거형 객체를 정의할 때는 **enum** 키워드를 사용한다.
    - **중괄호 블록 내에는 데이터 멤버들이 case 키워드와 함께 정의된다.**
    - 열거형을 정의하는 방법 **enum** 열거형 이름 { case 멤버값 1 case 멤버값 2 case... }
    - **열거형은 점 구문을 이용하여 값을 불러올 수 있다.**
    - **이 값들은 변수나 상수, 함수의 인자값으로 사용된다.**
    - 다음 경우에 열거형 타입명을 생략할 수 있다.
    - **열거형 타입으로 정의된 변수에는 열거형 타입명을 생략하고 맴버값만 대입해도 오류가 발생하지 않는다.**
    - **변수나 상수의 타입 어노테이션을 명시한 경우, 처음부터 타입명을 생략하고 멤버값만 대입해도 오류가 발생하지 않는다.**
    - **타입 어노테이션 없이 변수나 상수를 초기화할 때 타입명은 생략할 수 없다.**
    - **열거형 타입으로 정의된 변수는 switch 구문에서 분기 멤버와 비교하는 분기 구문을 사용 할 수 있다.**
    - **이때 열거형에 정의된 멤버를 switch 구문의 case 블록 비교에 전부 사용하면 defalut 구문은 생략할 수 있다.**
    - **Swift 에서는 열거형의 멤버에 실질적인 값을 할당할 수 있도록 한다.**
    - **이때 중괄호 앞에 타입 어노테이션을 표기해야 한다.**
    - **사용하는 시점에서 멤버에 보조 값을 설정하는 것**을 **연관 값**이라고 한다.
    - 열거형은 메소드의 호출 옵션이나 스타일을 설정할 때 열거형으로 미리 정의해둔 멤버들을 속성값으로 사용하는 경우가 많다.

3. 익스텐션
    - **익스텐션**은 **이미 존재하는 클래스나 구조체, 열거형 등의 객체에 새로운 기능을 추가하여 확장해주는** 구문이다.
    - Swift 에서 익스텐션을 통해 구현할 수 있는 것들은 대표적으로 다음과 같다.
    - **새로운 연산 프로퍼티를 추가할 수 있다.**
    - **새로운 메소드를 정의할 수 있다.**
    - **새로운 초기화 구문을 추가할 수 있다.**
    - **기존 객체를 수정하지 않고 프로토콜을 구현할 수 있다.**
    - 익스텐션을 사용할 때에는 **extention**키워드를 사용한다.
    - 익스텐션의 사용법 **extention 확장할 기존 객체명 { 추가할 기능의 구현 코드 }**
    - **익스텐션으로 추가할 수 있는 프로퍼티는 연산 프로퍼티로 제한된다.**
    - **익스텐션으로 인스턴스 메소드나 타입 메소드를 새로 정의할 수 있다.**
    - **이떄 오버로딩 사용 가능하다.**
    - **같은 메소드를 재정의할수는 없다.**
    - **구조체나 열거형에서 정의된 메소드가 자기 자신의 인스턴스를 수정하거나 프로퍼티를 번경할 때 mutating키워드를 앞에 붙여주어야 한다.**
    - **익스텐션으로 정의한 메소드는 기존의 클래스 정의와 구분되어 점프 바에서 별도의 그룹으로 표시된다.**
    - ### **액션 메소드에는 익스텐션에 작성할 수 없다.**


=========


# 프로토콜


-  iOS에서는 이벤트를 효율적으로 관리하기 위해서 **대리자**를 지정하여 이벤트 처리를 **위임** 하고 대리자가 콜백 매소드를 호출해주는 **델리게이트 패턴**을 많이 사용하는데, 이 패턴을 구현하지 위해 이용하는 것이 **프로토콜**이다.
- 구조체나 클래스를 구현하는 과정에서도 프로토콜을 사용하여 구현할 메소드릐 형식을 공통으로 정의할 수 있다.
- 프로토콜을 구현한 객체의 메소드나 속성을 은닉하고 프로토콜에서 선언된 명세의 내용만 제공하는 기능도 한다.
- 프로토콜에 선언된 프로퍼티나 메소드의 형식을 프로토콜의 **명세**라고 한다.
- 이 명세에 맞추어 실질적 내용을 작성하는 것을 **프로토콜을 구현**한다고 한다.
- 프로토콜의 구현은 프로토콜을 상속받는 구조체나 클래스에서 담당한다.

1. 프로토콜의 정의
    - 프로토콜을 정의할 때에는 **protocol** 키워드를 사용한다.
    - 프로토콜을 정의하는 방법 **protocol 프로토콜명 { 구현해야 할 프로퍼티 명세 1, 2, 3... }
    - Swift 에서 프로토콜을 구현할 수 있는 구현체들은 다음과 같다.
    - **구조체**
    - **클래스**
    - **열거형**
    - **익스텐션**
    - 프로토콜을 구현하기 위한 방법 **객체명 : 구현할 프로토콜 명 { }**
    - 프로토콜에 선언되는 프로퍼티에는 **초기값을 할당할 수 없다.**
    - 단지 **프로퍼티의 종류, 이름, 변수/상수 구분, 타입, 읽기 전용인지 수정이 가능한지에 대해서만 정의가 가능**하다. EX) protocol school { var chair : String { get get } varc desk : String { get set } }
    - **읽기 전용의 프로토콜에는 get 만, 쓰기가 가능할때는 get, set 둘 다 적어준다.**
    - **프로토콜에 선언되는 메소드는 반환값이 선택사항이다.** 
    - 하지만 **메소드의 선언 뒤에 중괄호 블록이 없다.**
    - ### **프로토콜은 설계도일 뿐 구현은 구조체나 클래스 열거형 또는 익스텐션의 역할이다.**
    - **내부 매개변수는 프로토콜을 그대로 따르지 않고 변형이 가능하다.**
    - **단 어떤 경우라도 메소드명과 외부 파라미터는 항상 그대로 따라야 한다.**
    - 프로토콜에서 메소드 선언에 mutanting 키워드가 붙지 않는 것은 다음 두 가지 중 하나이다.
    - **구조체나 열거형 등 값 타입의 객체에서 내부 프로퍼티의 값을 번경하기를 원치 않을 때**
    - **주로 클래스를 대상으로 간주하고 작성한 프로토콜일 때**
    - **프로토콜에서 static 키워드로 선언되었더라도, 실제로 클래스에서 구현할때는 필요에 따라 static과 class 를 선택하여 사용할 수 있다.**
    - **프로토콜에서 초기화 메소드를 정의하려면 init 구문을 사용해주면 된다.**
    - 프로토콜의 초기화의 주의점은 다음과 같다.
    - **구현되는 초기화 메소드의 이름과 매개변수명은 프로토콜의 명세에 작성된 것과 완전히 일치해야 한다.**
    - **프로토콜 명세에 선언된 초기화 메소드는 그것이 기본 제공되는 초기화 메소드일지라도 직접 구현해야 한다.**
    - **클래스에서 초기화 메소드를 구현할 때에는 required 키워드를 붙여야 한다.**
    - 클래스는 **상속과 프로토콜 구현이 동시에 가능한 객체**이다.
    - **프로토콜은 여러 개를 동시 구현할 수 있다.**
    
2. 타입으로서의 프로토콜
    - 프로토콜은 다음과 같은 상황에서도 사용할 수 있다.
    - **상수나 변수, 그리고 프로퍼티의 타입으로 사용할 수 있다.**
    - **함수, 매소드, 또는 초기화 구문에서 매개변수 타입이나 반환 타입으로 프로토콜을 사용할 수 있다.**
    - **배열이나 사전, 혹은 다른 컨테이너의 타입으로 사용할 수 있다.**
    - 이렇게 프로토콜 타입으로 정의된 변수나 상수에 할당된 객체는 프로토콜 이외의 구현체에서 추가한 프로퍼티나 메소드들을 컴파일러로부터 **은닉** 해준다.
    - 객체 본래 타입이 아니라 프로토콜 타입으로 선언한 변수나 상수에 할당받아 사용하는 것은 **특정 프로토콜을 구현한 모든 클래스나 구조체를 변수나 상수에 할당할 수 있다는 장점이 있다.**

3. 델리게이션
    - 프로토콜 타입으로 선언된 값을 사용한다는 것은, **여기에 할당된 객체가 구체적으로 어떤 기능을 갖추고 있는지는 상관없다는 뜻이기도 한다.**
    - **델리게이션**은 **델리게이트 패턴**이라는 **특정 기능을 다른 객체에 위임하고, 그에 따라 필요한 시점에서 메소드의 호출만 받는 패턴**을 이해하는데 아주 중요한 개념이다.
    - 델리게이션은 **텔리게이트 참조를 통해 메소드를 호출할 인스턴스 객체를 전달받고, 이 인스턴스 객체가 구현하고 있는 프로토콜에 선언된 메소드를 호출하는 것이다.

4. 프로토콜의 활용
    - 클래스나 구조체 열거형 등의 특정 객체에서 프로토콜을 구현해야 할 경우, 객체 자체의 코드를 수정할수도 있지만, 이를 대신하여 **익스텐션에서 프로토콜을 구현할 수 있다.**
    - 익스텐션에서 프로토콜을 구현하는 방법 **extension 기존 객체 : 구현할 프로토콜1, 2 ... { 프로토콜의 요소에 대한 구체적인 내용 }
    - 이떄 **확장하기 전 본래의 객체에서는 프로토콜을 구현하지 않았더라도 익스텐션에서 프로토콜을 구현한다면 해당 객체는 프로토콜을 구현한 것으로 처리된다.**
    - ### **프로토콜에서 정의된 프로퍼티를 익스텐션에서 구현해야 한다면, 반드시 연산 프로퍼티로 구현해 주어야 한다.**
    - **프로토콜도 상속을 통해 정의된 프로퍼티나 메소드, 초기화 블록의 선언을 물려줄 수 있다.**
    - 이때, **다중 상속이 가능하다.** ( 여러 개의 프로토콜을 하나의 프로토콜에 한꺼번에 상속하여 각 프로토콜의 명세를 하나의 프로토콜에 담을 수 있다는 의미이다. )
    - 상속 관계가 성립된 프로토콜은 **is, as 와 같은 타입 연산자들을 이용하여 타입 비교와 변환을 할 수 있다.**
    - is 연산자와는 달리 as 연산자는 다음 제한된 범위 안에서 타입을 캐스팅할 수 있다.
    - **실제로 할당된 인스턴스 타입**
    - **인스턴스가 구현한 프로토콜 타입**
    - **클래스가 상속을 받았을 경우 모든 상위 클래스**
    - **프로토콜 타입이 상속을 받았을 경우 모든 상위 프로토콜**
    - 프로토콜에서의 타입 캐스팅은 **공통 타입으로 선언된 객체의 인스턴스를 필요한 타입으로 적절히 변환하여 본래 인스턴스가 가지고 있던 고유한 기능들을 사용할 수 있도록 해준다.**
    - **프로토콜의 이름 뒤에 있는 콜론 뒤에 class 키워드를 넣음으로써 class 전용 프로토콜을 정의할 수 있다.**
    - 이 경우 **mutanting 키워드는 붙일 수 없지만, static 키워드는 붙일 수 있다,**
    - 프로토콜 앞에 **@objc**키워드를 표시하고, optional 키워드를 붙이면 프로토콜을 구현할 때 작성해야 하는 요소들을 선택 사항으로 바꿔준다. 이를 **선택적 요청**이라고 한다.
    - 이때 @objc 키워드는 objective-C 코드에서 참조할 수 있다는 것을 의미한다.


=========


# 오류 처리


- 옵셔널에는 오류가 발생했을 때 오류에 대한 정보를 **외부로 전달할 방법이 없다**는 것이다.
- 따라서 Swift 에서는 오류를 처리하는 방법으로 실행 흐름 중간에 **오류 객체를 만들어 다른 실행 흐름으로 옮기는 것을 지원한다.**
- 오류 처리를 위해서는 오류 타입 객체가 필요하다.
- 오류 처리를 하기 위한 가장 적절한 객체 타입은 **열거형**이다.
- 오류 타입으로 사용되는 열거형을 정의하기 위해서는 **Error 라는 이름의 프로토콜을 구현**해야 한다.
- 이 프로토콜은 **오류 타입으로 사용해도 된다**는 **인증마크**인 셈이다.
- 정의 구문을 작성할 때 **throws** 키워드를 반환 화살표 앞에 추가해야 **값을 던질 수 있다**는 의미가 된다.
- **do { try 오류를 던질 수 있는 함수 } catch 오류타입 1 { 오류 타입 1에 대한 내용 } catch 오류 타입 2 { 오류 타입 2 에 대한 내용 }...** 의 방법으로 오류 객체를 잡을 수 있다.
- 필요에 의해 오류를 던지게 하고 싶지 않을 때는 try 키워드 대신 **try!** 키워드를 사용한다.

  
    # 많이 읽고 복습해야 제대로 활용할 수 있습니다.
