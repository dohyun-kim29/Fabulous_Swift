# 집단 자료형


1. 배열
- **배열**은 **일련의 순서를 가지는 리스트 형식의 값을 저장**하는데에 사용되는 **자료형**이다.
- **배열 안의 값을 순서대로 일련번호 형식으로 나타내는 것**이 **Index**다.
### **Index는 0부터 시작한다.**
- 배열 중간의 값이 삭제되더라도 다른 값들이 앞으로 이동하며 빈 Index를 채워넣는다.

- 따라서 마지막 인덱스는 배열의 크기보다 항상 1만큼 작다.

- 배열에 저장할 아이템의 타입에는 제약이 없지만, **하나의 배열에 저장하는 아이템 타입은 모두 같아야 한다.**

- 배열을 선언해줄 때 배열에 저장할 아이템 타입을 명확히 정의해야 한다.

- **배열의 크기는 동적으로 확장할 수 있다.**

- 배열은 **정적** 또는 **동적** 으로 정의할 수 있다.                       

- 배열을 정적인 방식으로 선언하는법

` var 배열 이름  =  [데이터 1, 데이터2, 데이터n...]`

`var 급식 = ["chicken", "milk", "rice"]`

- 배열을 **순회 탐색할 때에는 보통 for~in 구문**과 **반 닫힌 범위 연산자**를 많이 사용한다.`

- 배열의 길이를 구할 때에는 배열 변수나 상수에 **.count** 를 붙여주면 된다.

`print(급식.count)`

- 또한 **이터네이터** 를 사용하는 방법이 있다. **for~in 구문에 배열을 넣어주면** 루프 상수에 할당되는 것이다.

`for 급식 in 0..<3`

- index(of:) 메소드를 사용해 아이템이 몇 번째 인덱스에 저장되어있는지 알아낼 수 있다.

`print(급식.index(of:"chicken"))`

- 배열을 동적인 방법으로 선언하고 초기화 할 때

` var 배열이름  =  Array <아이템 타입> (배열 안에 들어갈 내용) `

`var 1학년2반 = Array <String> ("밍기", "준상")`

- 배열을 동적인 방법으로 선언할때에는 **선언과 초기화를 분리**할 수 도 있다.

**선언**       `var 배열이름 : Array <아이템 타입>`

**초기화**   `선언이 완료된 배열 이름 = Array()`

- ### **초기화할 때에는 아이템 타입을 생략할 수 있다.**

- 배열이 비었는지 체크할 때에는 메소드 **isEmpty** 를 사용하면 된다. 이 메소드는 **배열이 비어있으면 true, 비어있지 않으면 false를 반환**한다.

`print(1학년2반.isEmpty)`

- 배열에 값을 동적으로 추가하고 싶을 때

`1학년2반.append( "도현":)`

`1학년2반.insert( "대성":at:1)`

`1학년2반.append(contentsOf:"어진")`

- **append(_:)** 메소드는 **배열의 크기를 1만큼 확장하고, 입력된 값을 배열의 맨 뒤에 추가한다.** 

- **insert(_:at:)** 메소드는 **아이템을 끼어들기 시켜 원하는 위치에 넣을 때 사용된다. at 뒤에 입력되는 정수값은 배열에서 아이템이 추가될 인덱스의 위치를 의미한다.**

- **append(contentsOf:)** 메소드는 **여러 개의 아이템을 배열에 한꺼번에 추가할 때 쓰는 메소드이다.**

- **입력된 배열값을 번경하고 싶을 때에는 기존 인덱스에 연결된 아이템을 교체하면 된다.**

`1학년2반[1] = "용성"`

- 단 **없는 인덱스에 배열을 추가할 수는 없다.** 이 경우 **오류가 발생**한다.

- **범위 연산자를 이용하여 인덱스를 참조할 수 있다.**

`print(1학년2반[0..<2])`

2. 집합
- **집합**은 **같은 타입의 서로 다른 값을 중복 없이 저장**하고자 할 때 사용되는 **집단 자료형**이다.  

- 주로 **중복 없이 한 번만 저장되어야 하는 데이터를 다룰 때 배열 대신 사용한다.**

- ### **인덱스가 없다.**

- **해시 연산**의 결과값을 이용하여 데이터를 저장하므로, **Hashable 프로토콜을 구현해야 한다.**

- **Set**이란 키워드를 사용하여 정의한다. 

`var meal : Set = ["시리얼", "우유", "치킨텐더"]`

- 나머지 값으로 사용되는 데이터 리터럴은 배열과 동일하다.

- 빈 배열을 작성하려면 **타입 어노테이션에서 아이템 타입을 작성해야 한다.** 

`var dinner : Set<String> = ["밥", "국", "음료수"]`

- **isEmpty 메소드 사용 가능하다.**

- 집합과 동일한 방식으로 순회 탐색을 할 수 있다.

- **sorted( )** 메소드를 사용하여 abc순서대로 정렬할 수 있다.

`dinner.sorted( )`

- 집합에 아이템을 동적으로 추가할 떄에는 **배열과 동일하게 insert(_:) 메소드를 사용**한다.

- 다만 **삭제할 때에는 remove(_:)메소드를 사용**한다. 

- 그러나 **삭제할 값이 집합에 없으면 remove(:_)메소드는 아무것도 삭제하지 않고 nil 을 반환**한다.

- **contains(_:)** 메소드는 인자값으로 입력된 데이터를 사용하여 **집합 안에 일치하는 데이터가 있는지 없는지 알려준다.**(Bool값으로 알려준다.)

- **집합끼리는 연산을 할 수 있다.**  EX) arr1.intersection(arr2)

- **intersection(_:) 메소드는 양쪽에서 공통된 아이템만 선택하여 새로운 집합을 만들어준다.**

- **symmetric Difference(_:) 메소드는 양쪽에서 어느 한 쪽에만 있는 아이템을 선택하여 새로운 집합을 만들어준다.(공통으로 있는 아이템은 제외)**

- **union(_:) 메소드는 양쪽 모두에 있는 아이템을 모두 선택해 새로운 집합을 만들어준다.(공통으로 있는 아이템이라고 해서 중복되지 않음)**

- **subtract(_:) 메소드는 한쪽 집합에 있는 모든 아이템에서 다른쪽 집합에도 속하는 공통 아이템을 제외하고 새로운 집합을 만들어준다.**

- subtract(_:) 메소드를 제외하고는 양쪽 집합의 위치가 바뀌어도 결과는 동일하다.

- 또한 포함관계를 판단해주는 연산도 가능하다.

- **isSubject(of:) 메소드는 주어진 집합의 값 전체가 특정 집합에 포함되는지 여부를 판단하여 Bool 값을 반환해준다.**

- **isSuperest(of:) 메소드는 주어진 집합이 특정 집합의 모든 값을 포함하는지흫 판단하여 Bool 값을 반환해준다.**

- **isStrictSubject(of:)와 isStrictSuperset(of:) 메소드는 위의 두 메소드와 같지만, 두 집합이 서로 완전히 같은 경우 결과값을 다르게 반환해준다.(그냥 조금 더 엄격하다 정도..?)**

- **isDisjoint(with:) 메소드는 두 집합 사이의 공통 값을 확인하여 아무런 공통 값이 없을 때 true, 하나라도 있으면 false를 반환해준다.**

-  배열을 집합으로 번경한 뒤 다시 배열로 변경해 손쉽게 중복 값 제거가 가능하다,

3. 튜플
-  **하나의 튜플에 여러가지 타입의 아이템을 저장 가능 하다.**
- **상수의 성격을 띄어 한번 선언되면 값을 추가하거나 삭제 불가능하다.**
- **소괄호를 써서 정의한다.** EX) var tp = ("a", "b", 1, 2.2, true)
- **인덱스를 점으로 표기한다.** EX) tp.0
- 없는 인덱스를 참조시 오류가 발생한다,
- 아이템을 개별 변수나 상수로 할당받는 **바인딩**이 가능하다.
- **순회 탐색이 불가능하다.**
- 바인딩을 할 때 사용하지 않을 튜플 아이템은 언더바로 대체가 가능하다.

4. 딕셔너리
- **고유 키와 그에 대응하는 값을 연결하여 데이터를 저장하는 자료형이다.**
- 정의 형식은 **[ 키 : 데이터, 키 : 데이터]** 이런 식으로 정의할 수 있다.
- **하나의 키는 하나의 데이터에만 연결되어야 한다.**
- **같은 딕셔너리 내에서 키는 중복될 수 없다.**(중복해서 선언하면 아이템 수정으로 간주.)
- **데이터 타입엔 제한이 없으나, 하나의 딕셔너리 내에서는 같은 자료형을 사용하여야 한다.**
- **순회 탐색이 가능하다.**
- **키의 타입은 해시 연산이 가능해야 한다.**
- 빈 딕셔너리의 선언은 **Dictionary** 키워드를 통해 할 수 있다. EX) Dictionary <int, string> ( )
- 이것을 간단한 방식으로 줄이면 **[ 키로 사용할 타입 : 값으로 사용할 타입 ] ( )** 이렇게 선언해줄 수 있다.
- 딕셔너리 역시 isEmpty 메소드를 사용할 수 있다.
- **updateValut(_:forKey:)** 메소드를 통해 딕셔너리에 값을 할당할 수 있다. <딕셔너리 객체>.updateValue(<저장할 데이터>, forKey:<데이터를 참조 및 저장하는 데 사용할 키>)
- **removeValue(forKey:)** 메소드를 통해 딕셔너리에 값을 삭제할 수 있다.
- ### 딕셔너리에서 키를 호출해서 저장된 값을 불러올 때 **옵셔널** 형태로 반환한다.


=========


# 옵셔널


### **옵셔널 타입**은 **nill** 을 사용할 수 있는 타입을 부르는 말이다.

1. nill
- **값이 없다** 는 것을 나타내주는 특수한 값이다.
- nill을 반환하려면 해당 타입이 옵셔널 타입으로 정의되어있어야 한다.
- **정상적으로 값을 처리하지 못하는 상황이 발생하였을 때 nill을 반환**한다.
- **자료형에는 nill을 대입할 수 없다.**
- **옵셔널 타입으로 선언된 자료형에는 nill을 대입할 수 있다.**
- **모든 기본 자료형 앞에 Optional을 붙이면 옵셔널 타입이 된다.** EX) Optional Int, Optional String
- Swift 에서 옵셔널 타입이 가질 수 있는 값은 **nill이 아닌 값**과 **nill 값** 두 가지뿐이다.
- **성공적으로 처리되면 옵셔널로 감싸진 결과값이 반환되고. 문제가 있으면 nill이 반환된다.** EX) Optional(123)
- ### **옵셔널 타입은 반환하려는 값을 옵셔널로 감싼 형태이다.**
- 옵셔널로 싸여있는 것을 **옵셔널 래핑** 이라고 하고, 이를 헤제하는 과정을 **옵셔널 언래핑**이라고 한다.

2. 옵셔널 타입 선언, 정의

- ### **자료형 뒤에 ? 를 붙인다.**

3.  옵셔널 값 처리
- **옵셔널 언래핑을 해야지만 연산, 대입이 가능하다.**
- 옵셔널 언래핑의 방법에는 **명시적 해제**와 **묵시적 해제**가 있다.
- 명시적 해제법에는 **강제 해제**와 **비강제 해제**가 있다.
- 묵시적 해제법에는 **컴파일러에 의한 자동 해제**와, **! 연산자를 사용한 자동 해제**법이있다.
- ### **옵셔널 타입의 값 뒤에 !(강제 해제 연산자) 를 붙이면 강제 해제가 된다.**
- 하지만 **강제 해제 연산자를 사용하였을 때엔 nill 값일때도 강제 해제가 되어 오류가 발생**한다.
- **옵셔널 바인딩**을 통해 안전하게 해제가 가능하다.
- 옵셔널 바인딩은 **조건문 내에서 일반 상수에 옵셔널 값을 대입하는 방식**이다.
- 컴파일러에 의해 옵셔널이 자동으로 해제되는 경우가 있다.(**비교 연산을 처리할 때**)
- ### **!연산자를 사용해 옵셔널 타입을 선언할 수 있는데 이 때 옵셔널의 묵시적 해제가 일어나 일반 변수처럼 다룰 수 있다.**
- **이때 변수의 값이 nill이 될 가능성이 있다면 사용해서는 안된다.**



=========
