# 집단 자료형


1. 배열

   - **배열**은 **일련의 순서를 가지는 리스트 형식의 값을 저장**하는데에 사용되는 **자료형**이다.
   - **배열 안의 값을 순서대로 일련번호 형식으로 나타내는 것**이 **Index**다.

   ### **Index는 0부터 시작한다.**

   

   - 배열 중간의 값이 삭제되더라도 다른 값들이 앞으로 이동하며 빈 Index를 채워넣는다.

     

   - 따라서 마지막 인덱스는 배열의 크기보다 항상 1만큼 작다.

     

   - 배열에 저장할 아이템의 타입에는 제약이 없지만, **하나의 배열에 저장하는 아이템 타입은 모두 같아야 한다.**

     

   - 배열을 선언해줄 때 배열에 저장할 아이템 타입을 명확히 정의해야 한다.

     

   - **배열의 크기는 동적으로 확장할 수 있다.**

     

   - 배열은 **정적** 또는 **동적** 으로 정의할 수 있다.   

     ​                    

   - 배열을 정적인 방식으로 선언하는법

     ```swift
     var 배열 이름 = [데이터1, 데이터2, 데이터n]
     ```

     ```swift
     var lunchMenu = ["chicken", "milk", "rice"]
     ```

     

   - 배열을 **순회 탐색할 때에는 보통 for~in 구문**과 **반 닫힌 범위 연산자**를 많이 사용한다.`

   - 배열의 길이를 구할 때에는 배열 변수나 상수에 **.count** 를 붙여주면 된다.

     ```swift
     var yellowCity = ["Apdo", "MonsterRat", "Ralo", "Paka"]
     
     print(yellowCity.count)
     
     ------result------
     4
     
     ```




   - 또한 **이터네이터** 를 사용하는 방법이 있다. **for~in 구문에 배열을 넣어주면** 루프 상수에 할당되는 것이다.

     ```swift
     var hiphopLable = ["Ambition", "IMJM", "AOMG"]
     
     for hiphopLable in 0...3 {
       print(hiphopLable)
     }
     
     ------result------
     0
     1
     2
     3
     
     ```



- index(of:) 메소드를 사용해 아이템이 몇 번째 인덱스에 저장되어있는지 알아낼 수 있다.

  ```swift
  var rapper = ["Justhis", "Ash Island", "CHANGMO"]
  
  print(rapper.index(of:"Justhis"))
  
  ------result------
  optional(0)
  
  //여기서 나오는 optional은 뒤에서 다룬다 이를 없애주려면
  //print(rapper.index(of:"Justhis")!)로 고쳐주면 된다고만 알아두자.
  
  ```

  

- 배열이 비었는지 체크할 때에는 메소드 **isEmpty** 를 사용하면 된다. 이 메소드는 **배열이 비어있으면 true, 비어있지 않으면 false를 반환**한다.

  ```swift
  선언 완료된 배열 이름.isEmpty
  ```

  ```swift
  var myGirlfriend = [""]
  
  print(myGirlfriend.isEmpty)
  
  ------result------
  false
  
  ```

- 배열에 값을 동적으로 추가하고 싶을 때

  ```swift
  선언 완료된 배열 이름.append(추가할 데이터)
  ```

- **append(_:)** 메소드는 **배열의 크기를 1만큼 확장하고, 입력된 값을 배열의 맨 뒤에 추가한다.** 

  

  ```swift
  선언 완료된 배열 이름.insert(추가할 데이터, at:원하는 인덱스 위치)
  ```

- **insert(_:at:)** 메소드는 **아이템을 끼어들기 시켜 원하는 위치에 넣을 때 사용된다. at 뒤에 입력되는 정수값은 배열에서 아이템이 추가될 인덱스의 위치를 의미한다.**

  

  ```swift
  선언 완료된 배열 이름.append(contentsOf:[추가할데이터1, 추가할데이터2, 추가할데이터n...])
  ```

- **append(contentsOf:)** 메소드는 **여러 개의 아이템을 배열에 한꺼번에 추가할 때 쓰는 메소드이다.**

  

  ```Swift
  var todayDinner = [""]
  
  todayDinner.append("rice")
  todayDinner.insert("meat", at: 1)
  todayDinner.append(contentsOf: ["kimchi", "nutellaBanana"])
  
  print(todayDinner[0])
  print(todayDinner[1])
  print(todayDinner[2])
  print(todayDinner[3])
  print(todayDinner[4])
  
  ------result------
  
  meat
  rice
  kimchi
  nutellaBanana
  
  ```

  

- **입력된 배열값을 번경하고 싶을 때에는 기존 인덱스에 연결된 아이템을 교체하면 된다.**

  

  ```swift
  vvar 급식 = ["치킨"]
  print(급식[0])
  
  급식[0] = "굶어"
  print(급식[0])
  
  
  ------result------
  치킨
  굶어
  
  
  ```

  

  

- 단 **없는 인덱스에 배열을 추가할 수는 없다.** 이 경우 **오류가 발생**한다.

- **범위 연산자를 이용하여 인덱스를 참조할 수 있다.**

  ```swift
  var vacation = ["Sea", "Lake", " Mountain"]
  print(vacation[0..<2])
  
  ------result------
  
  ["Sea", "Lake"]
  ```

  

2. 집합 

   **집합**은 **같은 타입의 서로 다른 값을 중복 없이 저장**하고자 할 때 사용되는 **집단 자료형**이다.  

- 주로 **중복 없이 한 번만 저장되어야 하는 데이터를 다룰 때 배열 대신 사용한다.**

- ### **인덱스가 없다.**

- **해시 연산**의 결과값을 이용하여 데이터를 저장하므로, **Hashable 프로토콜을 구현해야 한다.**

    

- **Set**이란 키워드를 사용하여 정의한다. 

  `var 선언할 배열 이름 : Set = ["데이터1", "데이터2", "데이터n..."]`

  

  ```swift
  var furniture : Set = ["bed", "table", "chair"]
  print(furniture)
  
  ------result------
  
  ["table", "chair", "bed"]
  ```

  

- 나머지 값으로 사용되는 데이터 리터럴은 배열과 동일하다.

  

- 빈 집합을 작성하려면 **타입 어노테이션에서 아이템 타입을 작성해야 한다.** 

  `var 선언할 집합 이름 : Set<String> = ["데이터1", "데이터2", "데이터n..."]`

  

- **isEmpty 메소드 사용 가능하다.**

  `이방법은 배열과 거의 동일`

  

- 집합과 동일한 방식으로 순회 탐색을 할 수 있다.

  

- **sorted( )** 메소드를 사용하여 abc순서대로 정렬할 수 있다.

  `메소드를 사용할 배열명.sorted( )`

  ```swift
  var music : Set = ["pop", "rock", "Hip"]
  print(music)
  
  ------result------
  
  ["rock", "Hip", "pop"]
  ```

  

- 집합에 아이템을 동적으로 추가할 떄에는 **배열과 동일하게 insert(_:) 메소드를 사용**한다.

  `아이템을 추가할 배열 명.insert("추가할 아이템")`

   ```swift
  var choco : Set = ["dark", "milk"]
  print(choco)
  
  choco.insert("white")
  print(choco)
  
  ------result------
  
  ["milk", "dark"]
  ["milk", "white", "dark"]
   ```

  

- 다만 **삭제할 때에는 remove(_:)메소드를 사용**한다. 

  ```swift
  var dessert : Set = ["macaron", "cake"]
  print(dessert)
  
  dessert.remove("macaron")
  print(dessert)
  
  dessert.remove("candy")
  print(dessert)
  
  ------result------
  
  ["macaron", "cake"]
  ["cake"]
  ["cake"]
  ```

  - 그러나 **삭제할 값이 집합에 없으면 remove(:_)메소드는 아무것도 삭제하지 않고 nil 을 반환**한다.

  - ![image-20200528135137193](/Users/dohyunkim/Library/Application Support/typora-user-images/image-20200528135137193.png)

    위 코드를 실행했을 때의 중간 과정

    

  - **contains(_:)** 메소드는 인자값으로 입력된 데이터를 사용하여 **집합 안에 일치하는 데이터가 있는지 없는지 알려준다.**(Bool값으로 알려준다.)

    `메소드를 사용할 집합 이름.contains("찾아볼 데이터")`

    ```swift
    var school : Set = ["desk", "chair"]
    print(school.contains("desk"))
    
    ------result------
    
    true
    ```

    

    

  - **집합끼리는 연산을 할 수 있다.**  EX) arr1.intersection(arr2)

    `연산할 집합1.연산자(연산할 집합 2)`

    

  - **intersection(_:) 메소드는 양쪽에서 공통된 아이템만 선택하여 새로운 집합을 만들어준다.**

    ```swift
    var instrument1 : Set = ["piano", "guitar", "drum"]
    var instrument2 : Set = ["guitar", "violin", "triangle"]
    print(instrument1.intersection(instrument2))
    
    ------result------
    
    ["guitar"]
    ```

    

  - **symmetric Difference(_:) 메소드는 양쪽에서 어느 한 쪽에만 있는 아이템을 선택하여 새로운 집합을 만들어준다.(공통으로 있는 아이템은 제외)**

    ```swift
    var instrument1 : Set = ["piano", "guitar", "drum"]
    var instrument2 : Set = ["guitar", "violin", "triangle"]
    print(instrument1.symmetricDifference(instrument2))
    
    ------result------
    
    ["triangle", "violin", "drum", "piano"]
    ```

    

  - **union(_:) 메소드는 양쪽 모두에 있는 아이템을 모두 선택해 새로운 집합을 만들어준다.(공통으로 있는 아이템이라고 해서 중복되지 않음)**

    ```swift
    var instrument1 : Set = ["piano", "guitar", "drum"]
    var instrument2 : Set = ["guitar", "violin", "triangle"]
    print(instrument1.union(instrument2))
    
    ------result------
    
    ["guitar", "drum", "piano", "violin", "triangle"]
    ```

    

  - **subtract(_:) 메소드는 한쪽 집합에 있는 모든 아이템에서 다른쪽 집합에도 속하는 공통 아이템을 제외하고 새로운 집합을 만들어준다.**

    ```swift
    //Swift5 Playground 에서 제대로 동작하지 않아서 애플 공식문서 예문 첨부.
    
    var employees: Set = ["Alicia", "Bethany", "Chris", "Diana", "Eric"]
    let neighbors: Set = ["Bethany", "Eric", "Forlani", "Greta"]
    employees.subtract(neighbors)
    print(employees)
    
    -----result------
    
    ["Diana", "Chris", "Alicia"]
    ```

    

  - subtract(_:) 메소드를 제외하고는 양쪽 집합의 위치가 바뀌어도 결과는 동일하다.

  - 또한 포함관계를 판단해주는 연산도 가능하다.

    

  - **isSubset(of:) 메소드는 주어진 집합의 값 전체가 특정 집합에 포함되는지 여부를 판단하여 Bool 값을 반환해준다.**

    ```swift
    var school : Set = ["1-1","1-2","2-1","2-2"]
    var grade2 : Set = ["2-1", "2-2"]
    print(school.isSubset(of: grade2))
    print(grade2.isSubset(of: school))
    
    
    ------result------
    
    false
    true
    ```

    

  - **isSuperset(of:) 메소드는 주어진 집합이 특정 집합의 모든 값을 포함하는지를 판단하여 Bool 값을 반환해준다.**

    ```swift
    var school : Set = ["1-1","1-2","2-1","2-2"]
    var grade2 : Set = ["2-1", "2-2"]
    print(school.isSuperset(of: grade2))
    print(grade2.isSuperset(of: school))
    
    ------result------
    
    true
    false
    ```

    

    

  - **isStrictSubset(of:)와 isStrictSuperset(of:) 메소드는 위의 두 메소드와 같지만, 두 집합이 서로 완전히 같은 경우 결과값을 다르게 반환해준다.(그냥 조금 더 엄격하다 정도..?)**

    ```swift
    var same1 : Set = ["asd", "qwe", "zxc"]
    var same2 : Set = ["qwe", "asd", "zxc"]
    print(same1.isStrictSubset(of: same2))
    print(same1.isStrictSuperset(of: same2))
    
    ------result------
    
    false
    false
    ```

    

    

  

  

  - **isDisjoint(with:) 메소드는 두 집합 사이의 공통 값을 확인하여 아무런 공통 값이 없을 때 true, 하나라도 있으면 false를 반환해준다.**

    ```swift
    var school : Set = ["1-1","1-2","2-1","2-2"]
    var grade2 : Set = ["2-1", "2-2"]
    print(school.isDisjoint(with: grade2))
    
    ------result-------
    
    false
    ```

    

  - 배열을 집합으로 번경한 뒤 다시 배열로 변경해 손쉽게 중복 값 제거가 가능하다.

3. 튜플

   - **하나의 튜플에 여러가지 타입의 아이템을 저장 가능 하다.**

     

   - **상수의 성격을 띄어 한번 선언되면 값을 추가하거나 삭제 불가능하다.**

     

   - **소괄호를 써서 정의한다.** EX) var tp = ("a", "b", 1, 2.2, true)

     `var 선언할 튜플 이름 = (데이터1, 데이터2, 데이터n...)`

     ```swift
     var tp = (1, 2, "asd")
     print(tp)
     
     ------result------
     
     (1, 2, "asd")
     ```

     

   - **인덱스를 점으로 표기한다.** EX) tp.0

     `튜플이름.인덱스`

     ```swift
     var foo = (1, 2, "bar")
     print(foo.1)
     
     ------result------
     
     2
     ```

     

   - 없는 인덱스를 참조시 오류가 발생한다,

   - 아이템을 개별 변수나 상수로 할당받는 **바인딩**이 가능하다.

     ```swift
     var sampletp = ("test", 123)
     switch sampletp {
     case let(string, number): print("string = \(string), num = \(number)")
         
     default:
         break
     }
      
     ------result------
     
     string = test, num = 123
     ```

     

   - **순회 탐색이 불가능하다.**

     

   - 바인딩을 할 때 사용하지 않을 튜플 아이템은 언더바로 대체가 가능하다.

     ```swift
     var sampletp = ("test", 123, 534254)
     switch sampletp {
     case let(string, number, _): print("string = \(string), num = \(number)")
         
     default:
         break
     }
     
     ------result------
     
     string = test, num = 123
     ```

     

4. **딕셔너리**(중요중요정말중요)

   - **고유 키와 그에 대응하는 값을 연결하여 데이터를 저장하는 자료형이다.**

     

   - **딕셔너리 정의 형식**

     `var 딕셔너리 이름 = [키1:데이터1, 키2:데이터2, 키n...:데이터n...]

     ```swift
     var fastfood = ["hamburger":"burgerking", "pizza":"dominopizza", "chicken":"BHC"]
     print(fastfood["hamburger"])
     
     ------result------
     
     Optional("burgerking")
     ```

     

   - **하나의 키는 하나의 데이터에만 연결되어야 한다.**

     

   - **같은 딕셔너리 내에서 키는 중복될 수 없다.**(중복해서 선언하면 아이템 수정으로 간주.)

     

   - **데이터 타입엔 제한이 없으나, 하나의 딕셔너리 내에서는 같은 자료형을 사용하여야 한다.**

     

   - **순회 탐색이 가능하다.**

     

   - **키의 타입은 해시 연산이 가능해야 한다.**

     

   - 빈 딕셔너리의 선언은 **Dictionary** 키워드를 통해 할 수 있다.

     ` var  Dictionary <키의 자료형, 데이터의 자료형> ( )`

     ```swift
     var blank = Dictionary<Int, String>()
     ```

     

   - 이것을 간단한 방식으로 줄이면 

     `var 선언할 딕셔너리 이름 = [ 키로 사용할 타입 : 값으로 사용할 타입 ] ( )`

     ```swift
     var emptyDic = [Int:String]()
     ```

     

   - 딕셔너리 역시 isEmpty 메소드를 사용할 수 있다.

     

   - **updateValut(_:forKey:)** 메소드를 통해 딕셔너리에 값을 할당할 수 있다.

     ` 딕셔너리 객체.updateValue(저장할 데이터, forKey:데이터를 참조 및 저장하는 데 사용할 키)`

     ```swift
     var num = [String:Int]()
     num.updateValue(123, forKey: "number")
     print(num["number"])
     
     ------result------
     
     Optional(123)
     ```

     

   - **removeValue(forKey:)** 메소드를 통해 딕셔너리에 값을 삭제할 수 있다.

     ```swift
     var num = [String:Int]()
     num.updateValue(123, forKey: "number")
     print(num["number"])
     
     num.removeValue(forKey: "number")
     print(num)
     
     ------result------
     
     Optional(123)
     [:]
     
     ```

     

   - ### 딕셔너리에서 키를 호출해서 저장된 값을 불러올 때 **옵셔널** 형태로 반환한다.



